<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaScript | StudyBlog</title><meta name="keywords" content="小涛,博客,blog,xiaotao.cloud,blog.xiaotao.cloud,xiaotao,cloud"><meta name="author" content="Xiao Tao,2177393158@qq.com"><meta name="copyright" content="Xiao Tao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScriptJavaScript，通常缩写为 JS，是一种解释执行的编程语言。它是现在最流行的脚本语言之一。 JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程、命令式编程、函数式编程。 JavaScript 是属于 Web 的语言，它被设计为向 HTML 页面增加交互性。 在客户端，JavaScript 在传统意义上被实现为一种解释语言，但现在已">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="http://example.com/posts/cc1b9611.html">
<meta property="og:site_name" content="StudyBlog">
<meta property="og:description" content="JavaScriptJavaScript，通常缩写为 JS，是一种解释执行的编程语言。它是现在最流行的脚本语言之一。 JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程、命令式编程、函数式编程。 JavaScript 是属于 Web 的语言，它被设计为向 HTML 页面增加交互性。 在客户端，JavaScript 在传统意义上被实现为一种解释语言，但现在已">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.maho.cc/random-img/pc.php?9">
<meta property="article:published_time" content="2023-02-23T03:24:55.624Z">
<meta property="article:modified_time" content="2022-08-29T07:25:27.000Z">
<meta property="article:author" content="Xiao Tao">
<meta property="article:tag" content="小涛,博客,blog,xiaotao.cloud,blog.xiaotao.cloud,xiaotao,cloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.maho.cc/random-img/pc.php?9"><link rel="shortcut icon" href="/img/xiaotao.png"><link rel="canonical" href="http://example.com/posts/cc1b9611"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Xiao Tao","link":"链接: ","source":"来源: StudyBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-29 15:25:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.0.5/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="StudyBlog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cravatar.cn/avatar/e2e440da3c8f5379912c8a9c4df4e420?s=96&amp;d=https%3A%2F%2Fcn.gravatar.com%2Favatar%2Fb745710ae6b0ce9dfb13f5b7c0956be1&amp;r=g" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-tags"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-tags"></i><span> 说说</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.maho.cc/random-img/pc.php?9')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">StudyBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-tags"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-tags"></i><span> 说说</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-23T03:24:55.624Z" title="发表于 2023-02-23 11:24:55">2023-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-29T07:25:27.000Z" title="更新于 2022-08-29 15:25:27">2022-08-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript，通常缩写为 JS，是一种解释执行的编程语言。它是现在最流行的脚本语言之一。</p>
<p>JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程、命令式编程、函数式编程。</p>
<p>JavaScript 是属于 Web 的语言，它被设计为向 HTML 页面增加交互性。</p>
<p>在客户端，JavaScript 在传统意义上被实现为一种解释语言，但现在已经可以被即时编译（JIT）执行。随着最新的 HTML5 和 CSS3 语言标准的推行，它还可用于游戏、桌面和移动应用程序的开发，以及在服务器端网络环境运行，如 Node.js。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">// 第一行 JavaScript 代码</span></span><br></pre></td></tr></table></figure>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>可以使用 Chrome 的开发者工具测试代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-83b6a346249cc3ad.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>Chrome 开发者工具控制台</p>
<p>转到「控制台（Console）」，在这个面板里可以直接输入 JavaScript 代码，按回车后执行。</p>
<p>要查看一个变量的内容，在控制台中输入 <code>console.log(var-name);</code>，回车后显示的值就是变量的内容。</p>
<h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><h4 id="数字（number）"><a href="#数字（number）" class="headerlink" title="数字（number）"></a>数字（number）</h4><p>JavaScript 不区分整数和浮点数，统一用 number 表示，以下都是合法的 number 类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>;        <span class="comment">// 整数 123</span></span><br><span class="line"><span class="number">0.456</span>;      <span class="comment">// 浮点数 0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>;   <span class="comment">// 科学计数法表示 1.2345×1000，等同于 1234.5</span></span><br><span class="line">-<span class="number">99</span>;        <span class="comment">// 负数</span></span><br><span class="line"><span class="title class_">NaN</span>;        <span class="comment">// NaN 表示 Not a Number。当无法计算结果时用 NaN 表示</span></span><br><span class="line"><span class="title class_">Infinity</span>;   <span class="comment">// Infinity 表示无穷大。当数值超过了 JavaScript 的 Number 所能表示的最大值时，就表示为 Infinity</span></span><br></pre></td></tr></table></figure>
<p>number 可以直接做四则运算，规则和数学一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>;    <span class="comment">// 7.5</span></span><br><span class="line"><span class="number">2</span> / <span class="number">0</span>;              <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>;              <span class="comment">// NaN</span></span><br><span class="line"><span class="number">10</span> % <span class="number">3</span>;             <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>当对 number 做比较时，可以通过比较运算符得到一个布尔值。实际上，JavaScript 允许对任意数据类型做比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="number">0</span>;     <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> === <span class="number">0</span>;    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意相等运算符 <code>==</code>。JavaScript 在设计时，有两种比较运算符：</p>
<ul>
<li>第一种是 <code>==</code> 比较，它会自动转换数据类型再比较。很多时候，会得到非常诡异的结果；</li>
<li>第二种是 <code>===</code> 比较，它不会自动转换数据类型。如果数据类型不一致，返回 <code>false</code>；如果一致，再比较。</li>
</ul>
<p>由于 JavaScript 这个设计缺陷，<strong>不要使用 <code>==</code> 比较，应始终坚持使用 <code>===</code> 比较</strong>。</p>
<p>另一个例外是 <code>NaN</code> 这个特殊的 number 与所有其他值都不相等，包括它本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>唯一能判断 <code>NaN</code> 的方法是使用 <code>isNaN()</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="空（null）和未定义（undefined）"><a href="#空（null）和未定义（undefined）" class="headerlink" title="空（null）和未定义（undefined）"></a>空（null）和未定义（undefined）</h4><p><code>null</code> 表示一个“空”的值，<code>undefined</code> 表示值“未定义”。</p>
<blockquote>
<p>在其他语言中，也有类似 JavaScript 的 <code>null</code> 的空值，例如 Java 的 <code>null</code>、Swift 的 <code>nil</code>、Python 的 <code>None</code>。</p>
</blockquote>
<p>大多数情况下，都应该使用 <code>null</code>，<code>undefined</code> 仅仅在判断函数参数是否传递的情况下有用。</p>
<h4 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h4><p>JavaScript 的数组可以包含<strong>任意数据类型</strong>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>
<p>数组的元素可以通过索引来访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// 返回索引为 0 的元素，即 1</span></span><br><span class="line">arr[<span class="number">5</span>]; <span class="comment">// 返回索引为 5 的元素，即 true</span></span><br><span class="line">arr[<span class="number">6</span>]; <span class="comment">// 索引超出了范围，返回 undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="对象（object）"><a href="#对象（object）" class="headerlink" title="对象（object）"></a>对象（object）</h4><p>JavaScript 的对象是一组由键－值组成的无序集合，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&quot;js&quot;</span>, <span class="string">&quot;web&quot;</span>, <span class="string">&quot;mobile&quot;</span>],</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">    <span class="attr">hasCar</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">zipcode</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript 对象的键都是字符串类型，值可以是任意数据类型。上述 <code>person</code> 对象一共定义了 6 个键值对，其中每个键又称为对象的属性。例如，<code>person</code> 的 <code>name</code> 属性为 <code>&quot;Bob&quot;</code>，<code>zipcode</code> 属性为 <code>null</code>。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在 JavaScript 中，使用 <code>var</code> 声明变量。同一个变量可以反复赋值，而且可以是不同类型的值，但是要注意只能声明一次，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;    <span class="comment">// a 的值是整数 123</span></span><br><span class="line">a = <span class="string">&quot;ABC&quot;</span>;      <span class="comment">// a 变为字符串 &quot;ABC&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如 Java 是静态语言，赋值语句如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;  <span class="comment">// a 是整数类型变量，类型用 int 声明</span></span><br><span class="line">a = <span class="string">&quot;ABC&quot;</span>;    <span class="comment">// 错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure>
<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
</blockquote>
<p>要显示变量的内容，可以用 <code>console.log(var-name)</code>，打开 Chrome 的控制台就可以看到结果。使用 <code>console.log()</code> 代替 <code>alert()</code> 的好处是可以避免弹出烦人的对话框。</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>JavaScript 在设计之初，为了方便初学者学习，并不强制要求使用 <code>var</code> 声明变量。这个设计错误带来了严重的后果，未使用 <code>var</code> 声明的变量将会被视为全局变量：</p>
<p>i = 10; // i 现在是全局变量</p>
<p>JavaScript 在后来推出了严格模式，强制要求使用 <code>var</code> 声明变量，否则将导致运行错误。</p>
<p>启用严格模式的方法是在 JavaScript 代码的第一行写上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个字符串，不支持严格模式的浏览器会把它当做一个字符串语句执行，支持严格模式的浏览器将开启严格模式运行 JavaScript。</p>
<blockquote>
<p>不用 <code>var</code> 声明的变量会被视为全局变量。为了避免这一缺陷，所有的 JavaScript 代码都应该使用严格模式。在后面编写的 JavaScript 代码将全部采用严格模式。</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>由于多行字符串用 <code>\n</code> 写起来比较费事，所以 JavaScript 支持一种更简洁的方法——用反引号 <code>…</code> 表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`多行</span></span><br><span class="line"><span class="string">字符串</span></span><br><span class="line"><span class="string">测试`</span>);</span><br></pre></td></tr></table></figure>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用 <code>+</code> 号连接，而在变量很多的时候这样就显得很麻烦。JavaScript 支持一种模板字符串，表示方法同样是使用反引号，但是它会自动替换字符串中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好，<span class="subst">$&#123;name&#125;</span>，你今年 <span class="subst">$&#123;age&#125;</span> 岁了！`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br></pre></td></tr></table></figure>
<h4 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h4><p>要获取字符串某个指定位置的字符，使用类似数组的下标操作，索引号从 0 开始。</p>
<p>需要特别注意的是，<strong>字符串是不可变的</strong>。如果对字符串的某个索引赋值，不会有任何错误，但也没有任何效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;X&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// s 仍然为 &quot;Test&quot;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 为字符串提供了一些常用方法。注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p>
<h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><p><code>indexOf()</code> 会搜索指定字符串出现的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">s.<span class="title function_">indexOf</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// 返回 7，即子串的首字符的位置</span></span><br><span class="line">s.<span class="title function_">indexOf</span>(<span class="string">&quot;World&quot;</span>); <span class="comment">// 没有找到指定的子串，返回 -1</span></span><br></pre></td></tr></table></figure>
<h5 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h5><p><code>substring()</code> 返回指定索引区间的子串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">s.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 从索引 0 开始到 5（不包括 5），返回 &quot;hello&quot;</span></span><br><span class="line">s.<span class="title function_">substring</span>(<span class="number">7</span>);     <span class="comment">// 从索引 7 开始到结束，返回 &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>要取得数组的长度，直接访问 <code>length</code> 属性。</p>
<p>需要注意的是，<strong>直接给数组的 <code>length</code> 赋一个新的值会导致数组大小的变化</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="property">length</span>; <span class="comment">// 3</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr 加长为 [1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr 缩短为 [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>数组可以通过索引把对应的元素修改为新的值。</p>
<p>同样需要注意的是，如果通过索引赋值时，索引超过了范围，同样会引起数组大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">arr; <span class="comment">// arr 变为 [1, 2, 3, undefined, undefined, &quot;x&quot;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其它多数编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript 的数组却不会有任何错误。在编写代码时，不建议直接修改数组的大小，访问索引时要确保索引不会越界。</p>
</blockquote>
<h4 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h4><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><p><code>slice()</code> 对应于对应字符串中的 <code>substring()</code>，它截取数组的部分元素，然后返回一个新的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>];</span><br><span class="line">arr.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>);    <span class="comment">// 索引范围 [0, 3): [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span></span><br><span class="line">arr.<span class="title function_">slice</span>(<span class="number">3</span>);       <span class="comment">// 从索引 3 开始到结束: [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果不给 <code>slice()</code> 传递任何参数，就会从头到尾截取所有元素。利用这一点可以很容易地复制一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.<span class="title function_">slice</span>();</span><br><span class="line">aCopy;          <span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]</span></span><br><span class="line">aCopy === arr;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>同理，也可以不给字符串的 <code>substring()</code> 传递参数以得到复制的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> sCopy = s.<span class="title function_">substring</span>();</span><br><span class="line">sCopy; <span class="comment">// &quot;Hello, World!&quot;</span></span><br><span class="line">sCopy === s; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push 和 pop"></a>push 和 pop</h5><p><code>push()</code> 向数组的末尾添加若干元素，<code>pop()</code> 则删除数组的末元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);                 <span class="comment">// 返回数组新的长度: 4</span></span><br><span class="line">arr;                                <span class="comment">// [1, 2, &quot;A&quot;, &quot;B&quot;]</span></span><br><span class="line">arr.<span class="title function_">pop</span>();                          <span class="comment">// pop() 返回 &quot;B&quot;</span></span><br><span class="line">arr;                                <span class="comment">// [1, 2, &quot;A&quot;]</span></span><br><span class="line">arr.<span class="title function_">pop</span>(); arr.<span class="title function_">pop</span>(); arr.<span class="title function_">pop</span>();    <span class="comment">// 连续 pop 三次</span></span><br><span class="line">arr;                                <span class="comment">// []</span></span><br><span class="line">arr.<span class="title function_">pop</span>();                          <span class="comment">// 空数组继续 pop 不会报错，而是返回 undefined</span></span><br><span class="line">arr;                                <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h5 id="unshift-和-shift"><a href="#unshift-和-shift" class="headerlink" title="unshift 和 shift"></a>unshift 和 shift</h5><p><code>unshift()</code> 往数组的头部添加若干元素，<code>shift()</code> 则删除数组的首元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);                  <span class="comment">// 返回数组新的长度: 4</span></span><br><span class="line">arr;                                    <span class="comment">// [&quot;A&quot;, &quot;B&quot;, 1, 2]</span></span><br><span class="line">arr.<span class="title function_">shift</span>();                            <span class="comment">// &quot;A&quot;</span></span><br><span class="line">arr;                                    <span class="comment">// [&quot;B&quot;, 1, 2]</span></span><br><span class="line">arr.<span class="title function_">shift</span>(); arr.<span class="title function_">shift</span>(); arr.<span class="title function_">shift</span>();  <span class="comment">// 连续 shift 三次</span></span><br><span class="line">arr;                                    <span class="comment">// []</span></span><br><span class="line">arr.<span class="title function_">shift</span>();                            <span class="comment">// 空数组继续 shift 不会报错，而是返回 undefined</span></span><br><span class="line">arr;                                    <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p><code>sort()</code> 可以对当前数组进行排序，它会直接修改当前数组的元素位置。直接调用时，按照默认顺序排序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;A&quot;</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>();</span><br><span class="line">arr; <span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span></span><br></pre></td></tr></table></figure>
<p>至于按照指定的顺序排序，将会在后面的函数中讲到。</p>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p><code>reverse()</code> 把整个数组的元素反转：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>();</span><br><span class="line">arr; <span class="comment">// [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</span></span><br></pre></td></tr></table></figure>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h5><p><code>splice()</code> 是修改数组的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;Microsoft&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Yahoo&quot;</span>, <span class="string">&quot;AOL&quot;</span>, <span class="string">&quot;Excite&quot;</span>, <span class="string">&quot;Oracle&quot;</span>];</span><br><span class="line"><span class="comment">// 从索引 2 开始删除三个元素，然后再添加两个元素：</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Facebook&quot;</span>); <span class="comment">// 返回删除的元素 [&quot;Yahoo&quot;, &quot;AOL&quot;, &quot;Excite&quot;]</span></span><br><span class="line">arr;                                    <span class="comment">// [&quot;Microsoft&quot;, &quot;Apple&quot;, &quot;Google&quot;, &quot;Facebook&quot;, &quot;Oracle&quot;]</span></span><br><span class="line"><span class="comment">// 只删除，不添加：</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">2</span>);                       <span class="comment">// [&quot;Google&quot;, &quot;Facebook&quot;]</span></span><br><span class="line">arr;                                    <span class="comment">// [&quot;Microsoft&quot;, &quot;Apple&quot;, &quot;Oracle&quot;]</span></span><br><span class="line"><span class="comment">// 只添加，不删除：</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Facebook&quot;</span>); <span class="comment">// 返回空数组，因为没有删除任何元素</span></span><br><span class="line">arr;                                    <span class="comment">// [&quot;Microsoft&quot;, &quot;Apple&quot;, &quot;Google&quot;, &quot;Facebook&quot;, &quot;Oracle&quot;]</span></span><br></pre></td></tr></table></figure>
<h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p><code>concat()</code> 把当前数组和另一个数组连接起来，并返回一个新的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.<span class="title function_">concat</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added;  <span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, 1, 2, 3]</span></span><br><span class="line">arr;    <span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span></span><br></pre></td></tr></table></figure>
<p>实际上，<code>concat()</code> 可以接收任意个元素和数组，并且自动把数组拆开，然后全部添加到新的数组里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line">arr.<span class="title function_">concat</span>(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p><code>join()</code> 是一个非常实用的方法，它把当前数组的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">join</span>(<span class="string">&quot;-&quot;</span>); <span class="comment">// &quot;A-B-C-1-2-3&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果数组的元素不是字符串，将自动转换为字符串后再连接。</p>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>如果数组的某个元素又是一个数组，则可以形成多维数组，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&quot;-&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>上述数组包含三个元素，其中头两个元素本身也是数组。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript 的对象是一种无序的集合数据类型，它由若干键值对组成。</p>
<p>访问对象的属性通过 <code>.</code> 操作符完成，但这要求属性名必须是一个<strong>有效的变量名</strong>。如果属性名包含特殊字符，就必须用引号括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小红&quot;</span>,</span><br><span class="line">    <span class="string">&quot;middle-school&quot;</span>: <span class="string">&quot;No.1 Middle School&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>xiaohong</code> 的属性名 <code>middle-school</code> 不是一个有效的变量，就需要用引号括起来。访问这个属性也无法使用 <code>.</code> 操作符，必须用 <code>[&quot;xxx&quot;]</code> 来访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaohong[<span class="string">&quot;middle-school&quot;</span>];  <span class="comment">// &quot;No.1 Middle School&quot;</span></span><br><span class="line">xiaohong[<span class="string">&quot;name&quot;</span>];           <span class="comment">// &quot;小红&quot;</span></span><br><span class="line">xiaohong.<span class="property">name</span>;              <span class="comment">// &quot;小红&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在编写 JavaScript 代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过 <code>object.property</code> 的形式访问一个属性了。</p>
</blockquote>
<p>由于 JavaScript 的对象是动态类型，因此可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.<span class="property">age</span>;               <span class="comment">// undefined</span></span><br><span class="line">xiaoming.<span class="property">age</span> = <span class="number">18</span>;          <span class="comment">// 新增一个 age 属性</span></span><br><span class="line">xiaoming.<span class="property">age</span>;               <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.<span class="property">age</span>;        <span class="comment">// 删除 age 属性</span></span><br><span class="line">xiaoming.<span class="property">age</span>;               <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&quot;name&quot;</span>];    <span class="comment">// 删除 name 属性</span></span><br><span class="line">xiaoming.<span class="property">name</span>;              <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.<span class="property">school</span>;     <span class="comment">// 删除一个不存在的 school 属性不会报错</span></span><br></pre></td></tr></table></figure>
<p>如果要检测 <code>xiaoming</code> 是否拥有某一属性，可以用 <code>in</code> 操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;No.1 Middle School&quot;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.70</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">65</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> xiaoming;     <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;grade&quot;</span> <span class="keyword">in</span> xiaoming;    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>不过需要注意的是，如果 <code>in</code> 判断一个属性存在，这个属性不一定是 <code>xiaoming</code> 本身的，它可能是 <code>xiaoming</code> 继承得到的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;toString&quot;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>toString</code> 定义在 <code>object</code> 对象中，而所有对象最终都会在原型链上指向 <code>object</code>，所以 <code>xiaoming</code> 也拥有 <code>toString</code> 属性。</p>
<p>要判断一个属性是否是 <code>xiaoming</code> 自身拥有的，而不是继承得到的，可以用 <code>hasOwnProperty()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>);        <span class="comment">// true</span></span><br><span class="line">xiaoming.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;toString&quot;</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>在 <code>if (condition) &#123; … &#125;</code> 中，条件逻辑语句 <code>condition</code> 的结果有时不是布尔值。</p>
<p>JavaScript 把 <code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code> 和空字符串 <code>&quot;&quot;</code> 视为 <code>false</code>，其它值一律视为 <code>true</code>。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a>for … in</h4><p><code>for</code> 循环的一个变体是 <code>for … in</code> 循环，它可以把<strong>一个对象的所有属性</strong>依次循环出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&quot;Beijing&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &quot;name&quot;，&quot;age&quot;，&quot;city&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用 <code>hasOwnProperty()</code> 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&quot;Beijing&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &quot;name&quot;，&quot;age&quot;，&quot;city&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于数组也是对象，而其每个元素的索引被视为对象的属性，因此 <code>for … in</code> 循环可以直接循环出数组的索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);     <span class="comment">// &quot;0&quot;，&quot;1&quot;，&quot;2&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a[i]);  <span class="comment">// &quot;A&quot;，&quot;B&quot;，&quot;C&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<strong><code>for … in</code> 对数组循环得到的是字符串，而不是 <code>Number</code></strong>。</p>
<h3 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h3><p>JavaScript 默认的对象表示方式 <code>&#123;&#125;</code> 可以视为其它编程语言中的 <code>Map</code> 或 <code>Dictionary</code> 的数据结构，即一组键值对。</p>
<p>但是 JavaScript 的对象有个小问题，就是键必须是字符串。但实际上 <code>Number</code> 或者其它数据类型作为键也是非常合理的。</p>
<p>为了解决这个问题，JavaScript 引入了新的数据类型 <code>Map</code>。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code> 是一组键值对的结构，具有极快的查找速度。</p>
<p>举个例子，现在要根据学生的名字查找对应的成绩，若用数组实现，需要两个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Tracy&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure>
<p>给定一个名字，要查找对应的成绩，就先要在 <code>names</code> 中找到对应的位置，再从 <code>scores</code> 中取出对应的成绩。数组越长，耗时越长。</p>
<p>若用 <code>Map</code> 实现，只需要一个“名字”－“成绩”的对照表，直接根据名字查找成绩。无论这个表有多大，查找速度都不会慢。实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="string">&quot;Michael&quot;</span>, <span class="number">95</span>],</span><br><span class="line">    [<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>],</span><br><span class="line">    [<span class="string">&quot;Tracy&quot;</span>, <span class="number">85</span>]</span><br><span class="line">]);</span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&quot;Michael&quot;</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<p>创建 <code>Map</code> 需要一个二维数组，或者直接创建一个空 <code>Map</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;Adam&quot;</span>, <span class="number">67</span>);  <span class="comment">// 添加新的键值对</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&quot;Adam&quot;</span>);      <span class="comment">// 是否存在键「Adam」：true</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&quot;Adam&quot;</span>);      <span class="comment">// 67</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&quot;Adam&quot;</span>);   <span class="comment">// 删除键「Adam」</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&quot;Adam&quot;</span>);      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于一个键只能对应一个值，所以，多次对一个键放入值，后面的值会替代前面的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;Adam&quot;</span>, <span class="number">67</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;Adam&quot;</span>, <span class="number">88</span>);</span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&quot;Adam&quot;</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>Set</code> 和 <code>Map</code> 类似，也是一组键的集合，但不存储值。由于键不能重复，所以在 <code>Set</code> 中没有重复的键。</p>
<p>要创建一个 <code>Set</code>，需要提供一个数组作为输入，或者直接创建一个空 <code>Set</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>();             <span class="comment">// 空 Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);    <span class="comment">// 含 1、2、3</span></span><br></pre></td></tr></table></figure>
<p>重复元素在 <code>Set</code> 中自动被过滤：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&quot;3&quot;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>add(key)</code> 方法可以添加元素到 <code>Set</code> 中，可以重复添加，但不会有效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>delete(key)</code> 方法可以删除元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代（iterable）"><a href="#迭代（iterable）" class="headerlink" title="迭代（iterable）"></a>迭代（iterable）</h3><p>遍历数组可以采用下标循环，遍历 <code>Map</code> 和 <code>Set</code> 就无法使用下标。为了统一集合类型，引入了新的 <code>iterable</code> 类型，数组、<code>Map</code> 和 <code>Set</code> 都属于 <code>iterable</code> 类型。</p>
<p>具有 <code>iterable</code> 类型的集合可以通过新的 <code>for … of</code> 循环来遍历。</p>
<p><code>for … in</code> 循环由于历史遗留问题，它遍历的实际上是<strong>对象的属性名称</strong>。一个数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当手动给数组添加了额外的属性后，<code>for … in</code> 循环将带来意想不到的意外效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;name&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这往往不是想要的。</p>
<p><code>for … of</code> 循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;A&quot;, &quot;B&quot;, &quot;C&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更好的方式是直接使用 <code>iterable</code> 内置的 <code>forEach()</code> 方法，它接收一个函数，每次迭代就自动回调该函数。以数组为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element, index, array</span>) &#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素</span></span><br><span class="line">    <span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向数组本身</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[&quot;</span> + element + <span class="string">&quot;, index = &quot;</span> + index + <span class="string">&quot;]&quot;</span>); <span class="comment">// [A, index = 0]，[B, index = 1]，[C, index = 2]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Set</code> 与数组类似，但 <code>Set</code> 没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]);</span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// &quot;A&quot;，&quot;B&quot;，&quot;C&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Map</code> 的回调函数参数依次为值、键和 <code>Map</code> 本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&quot;x&quot;</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">&quot;y&quot;</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">&quot;z&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, key, map</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// &quot;x&quot;，&quot;y&quot;，&quot;z&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果对某些参数不感兴趣，由于 JavaScript 的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得数组的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// &quot;A&quot;，&quot;B&quot;，&quot;C&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以及获得 <code>Map</code> 的键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="string">&quot;Michael&quot;</span>, <span class="number">95</span>],</span><br><span class="line">    [<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>],</span><br><span class="line">    [<span class="string">&quot;Tracy&quot;</span>, <span class="number">85</span>]</span><br><span class="line">]);</span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &quot;Michael&quot;，&quot;Bob&quot;，&quot;Tracy&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义和调用"><a href="#函数定义和调用" class="headerlink" title="函数定义和调用"></a>函数定义和调用</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>在 JavaScript 中，定义函数的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有 <code>return</code> 语句，函数执行完毕后会返回 <code>undefined</code>。</p>
</blockquote>
<p>由于 JavaScript 的函数也是一个对象，上述定义的 <code>abs()</code> 函数实际上是一个函数对象，而函数名 <code>abs</code> 可以视为指向该函数的变量。</p>
<p>因此，第二种定义函数的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种方式下，<code>function (x) &#123; … &#125;</code> 是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量 <code>abs</code>，所以通过变量 <code>abs</code> 就可以调用该函数。</p>
<p>上述两种定义<strong>完全等价</strong>，注意第二种方式按照完整语法需要在函数体末尾加一个 <code>;</code>，表示赋值语句结束。</p>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>调用函数时，按顺序传入参数即可。</p>
<p>传入的参数比定义的少也没有问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">abs</span>(); <span class="comment">// 返回 NaN</span></span><br></pre></td></tr></table></figure>
<p>此时 <code>abs(x)</code> 函数的参数 <code>x</code> 将收到 <code>undefined</code>，计算结果为 <code>NaN</code>。</p>
<p>要避免收到 <code>undefined</code>，可以对参数进行检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Not a Number&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>JavaScript 有一个关键字 <code>arguments</code>，它只在函数内部起作用，并且指向当前函数的调用者传入的所有参数。<code>arguments</code> 类似数组但它不是一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x = &quot;</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg &quot;</span> + i + <span class="string">&quot; = &quot;</span> + <span class="variable language_">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x = 10</span></span><br><span class="line"><span class="comment">arg 0 = 10</span></span><br><span class="line"><span class="comment">arg 1 = 20</span></span><br><span class="line"><span class="comment">arg 2 = 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>利用 <code>arguments</code>，可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">abs</span>();      <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">abs</span>(<span class="number">10</span>);    <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">abs</span>(-<span class="number">9</span>);    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>实际上 <code>arguments</code> 最常用于判断传入参数的个数。可能会看到这样的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo(a[, b], c)</span></span><br><span class="line"><span class="comment">// 接收 2～3 个参数，b 是可选参数。如果只传两个参数，b 默认为 null：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 实际拿到的参数是 a 和 b，c为 undefined</span></span><br><span class="line">        c = b; <span class="comment">// 把 b 赋给c</span></span><br><span class="line">        b = <span class="literal">null</span>; <span class="comment">// b 变为默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>由于 JavaScript 函数允许接收任意个参数，于是就不得不用 <code>arguments</code> 来获取所有参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i, rest = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            rest.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来引入了 <code>rest</code> 参数，上面的函数可以改写为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, ...rest</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a = 1</span></span><br><span class="line"><span class="comment">b = 2</span></span><br><span class="line"><span class="comment">[ 3, 4, 5 ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a = 1</span></span><br><span class="line"><span class="comment">b = undefined</span></span><br><span class="line"><span class="comment">[]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>rest</code> 参数只能写在最后，前面用 <code>...</code> 标识。从运行结果可知，传入的参数先绑定 <code>a</code>、<code>b</code>，多余的参数以数组形式交给变量 <code>rest</code>。所以不再需要 <code>arguments</code> 就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，<code>rest</code> 参数会接收一个空数组（注意不是 <code>undefined</code>）。</p>
<h4 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h4><p>前面讲到了 JavaScript 引擎有一个在行末自动添加分号的机制，这可能会栽到 <code>return</code> 语句的一个大坑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// &#123; name: &quot;foo&quot; &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果把 <code>return</code> 语句拆成两行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，由于 JavaScript 引擎在行末自动添加分号的机制，上面的代码实际上变成了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 自动添加了分号，相当于 return undefined;</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125;; <span class="comment">// 这行语句已经没法执行到了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以正确的多行写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为 &#123; 表示语句尚未结束</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量作用域与解构赋值"><a href="#变量作用域与解构赋值" class="headerlink" title="变量作用域与解构赋值"></a>变量作用域与解构赋值</h3><p>与其它主流编程语言类似，JavaScript 的函数内变量的作用域为整个函数体，内部函数可以访问外部函数定义的变量。并且在内部函数和外部函数的变量重名时，将“屏蔽”外部函数的变量。</p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JavaScript 在进行函数定义时，会把所有声明的变量“提升”到函数前部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;Hello, &quot;</span> + y;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>
<p>虽然是严格模式，但语句 <code>var x = &quot;Hello, &quot; + y;</code> 并不报错，原因是变量 <code>y</code> 在稍后声明了。但是 <code>console.log</code> 显示 <code>Hello, undefined</code>，说明变量 <code>y</code> 的值为 <code>undefined</code>。这正是因为 JavaScript 引擎自动提升了变量 <code>y</code> 的声明，但没有提升变量 <code>y</code> 的赋值。</p>
<p>对于上述 <code>foo()</code> 函数，JavaScript 引擎看到的代码相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y; <span class="comment">// 提升变量 y 的声明，此时 y 为 undefined</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;Hello, &quot;</span> + y;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    y = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 JavaScript 的这一怪异“特性”，在函数内部定义变量时，请严格遵守“在函数内部首先声明所有变量”这一规则。最常见的做法是用一个 var 申明函数内部用到的所有变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="number">1</span>,      <span class="comment">// x 初始化为 1</span></span><br><span class="line">        y = x + <span class="number">1</span>,  <span class="comment">// y 初始化为 2</span></span><br><span class="line">        z, i;       <span class="comment">// z 和 i 为 undefined</span></span><br><span class="line">    <span class="comment">// 其他语句：</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// …</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript 默认有一个全局对象 <code>window</code>，全局作用域的变量实际上被绑定到 <code>window</code> 的一个属性。</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>全局变量会绑定到 <code>window</code> 上，不同的 JavaScript 文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量 MYAPP：</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">MYAPP</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量：</span></span><br><span class="line"><span class="variable constant_">MYAPP</span>.<span class="property">name</span> = <span class="string">&quot;myapp&quot;</span>;</span><br><span class="line"><span class="variable constant_">MYAPP</span>.<span class="property">version</span> = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数：</span></span><br><span class="line"><span class="variable constant_">MYAPP</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>把自己的代码全部放入唯一的命名空间 <code>MYAPP</code> 中，会大大减少全局变量冲突的可能。</p>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>由于 JavaScript 变量作用域实际上是函数内部，在 <code>for</code> 循环等语句块中无法定义具有局部作用域的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量 i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决块级作用域，引入了新的关键字 <code>let</code>，用 <code>let</code> 替代 <code>var</code> 可以声明一个块级作用域的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>使用 <code>const</code> 定义常量，<code>const</code> 与 <code>let</code> 都具有块级作用域。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>解构赋值，即同时对一组变量进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;ES6&quot;</span>];</span><br><span class="line"><span class="comment">// x、y、z 分别被赋值为数组对应元素：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y + <span class="string">&quot;, z = &quot;</span> + z); </span><br><span class="line"><span class="comment">// x = hello, y = JavaScript, z = ES6</span></span><br></pre></td></tr></table></figure>
<p>对数组元素进行解构赋值时，多个变量要用 <code>[…]</code> 括起来。</p>
<p>如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，嵌套层次和位置要保持一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y, [z]]] = [<span class="string">&quot;hello&quot;</span>, [<span class="string">&quot;JavaScript&quot;</span>, [<span class="string">&quot;ES6&quot;</span>]]];</span><br><span class="line">x; <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">y; <span class="comment">// &quot;JavaScript&quot;</span></span><br><span class="line">z; <span class="comment">// &quot;ES6&quot;</span></span><br></pre></td></tr></table></figure>
<p>解构赋值还可以忽略某些元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;ES6&quot;</span>]; <span class="comment">// 忽略前两个元素，只对 z 赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// &quot;ES6&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&quot;G-12345678&quot;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;No.4 middle school&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    passport</span><br><span class="line">&#125; = person;</span><br><span class="line"><span class="comment">// name、age、passport 分别被赋值为对应属性：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;, passport = &quot;</span> + passport); </span><br><span class="line"><span class="comment">// name = 小明, age = 20, passport = &quot;G-12345678&quot;</span></span><br></pre></td></tr></table></figure>
<p>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&quot;G-12345678&quot;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;No.4 middle school&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">        <span class="attr">street</span>: <span class="string">&quot;No.1 Road&quot;</span>,</span><br><span class="line">        <span class="attr">zipcode</span>: <span class="string">&quot;100001&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        city,</span><br><span class="line">        zip</span><br><span class="line">    &#125;</span><br><span class="line">&#125; = person;</span><br><span class="line">name; <span class="comment">// &quot;小明&quot;</span></span><br><span class="line">city; <span class="comment">// &quot;Beijing&quot;</span></span><br><span class="line">zip; <span class="comment">// undefined。因为属性名是 zipcode 而不是 zip</span></span><br><span class="line"><span class="comment">// 注意：address 不是变量，而是为了让 city 和 zip 获得嵌套的 address 对象的属性：</span></span><br><span class="line">address; <span class="comment">// Uncaught ReferenceError: address is not defined</span></span><br></pre></td></tr></table></figure>
<p>使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为 <code>undefined</code>，这和引用一个不存在的属性获得 <code>undefined</code> 是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&quot;G-12345678&quot;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;No.4 middle school&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 passport 属性赋值给变量 id：</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="attr">passport</span>: id</span><br><span class="line">&#125; = person;</span><br><span class="line">name;   <span class="comment">// &quot;小明&quot;</span></span><br><span class="line">id;     <span class="comment">// &quot;G-12345678&quot;</span></span><br><span class="line"><span class="comment">// 注意：passport 不是变量，而是为了让变量 id 获得 passport 属性：</span></span><br><span class="line">passport; <span class="comment">// Uncaught ReferenceError: passport is not defined</span></span><br></pre></td></tr></table></figure>
<p>解构赋值还可以使用默认值，这样就避免了不存在的属性返回 <code>undefined</code> 的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&quot;G-12345678&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 person 对象没有 single 属性，默认赋值为 true：</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    single = <span class="literal">true</span></span><br><span class="line">&#125; = person;</span><br><span class="line">name;   <span class="comment">// &quot;小明&quot;</span></span><br><span class="line">single; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">x</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 语法错误：Uncaught SyntaxError: Unexpected token =</span></span><br></pre></td></tr></table></figure>
<p>这是因为 JavaScript 引擎把 <code>&#123;</code> 开头的语句当作了块处理，于是 <code>=</code> 不再合法。解决方法是用小括号括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">x</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">200</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>解构赋值在很多时候可以大大简化代码。例如，交换两个变量 <code>x</code> 和 <code>y</code> 的值，可以这么写，不再需要临时变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
<p>快速获取当前页面的域名和路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    <span class="attr">hostname</span>: domain,</span><br><span class="line">    <span class="attr">pathname</span>: path</span><br><span class="line">&#125; = location;</span><br></pre></td></tr></table></figure>
<p>如果一个函数接收一个对象作为参数，那么可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个 <code>Date</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildDate</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    year,</span></span><br><span class="line"><span class="params">    month,</span></span><br><span class="line"><span class="params">    day,</span></span><br><span class="line"><span class="params">    hour = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">    minute = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">    second = <span class="number">0</span></span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day + <span class="string">&quot; &quot;</span> + hour + <span class="string">&quot;:&quot;</span> + minute + <span class="string">&quot;:&quot;</span> + second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的方便之处在于传入的对象只需要 <code>year</code>、<code>month</code> 和 <code>day</code> 这三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">buildDate</span>(&#123;</span><br><span class="line">    <span class="attr">year</span>: <span class="number">2017</span>,</span><br><span class="line">    <span class="attr">month</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">day</span>: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Sun Jan 01 2017 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<p>也可以传入 <code>hour</code>、<code>minute</code> 和 <code>second</code> 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">buildDate</span>(&#123;</span><br><span class="line">    <span class="attr">year</span>: <span class="number">2017</span>,</span><br><span class="line">    <span class="attr">month</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">day</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">hour</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">minute</span>: <span class="number">15</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Sun Jan 01 2017 20:15:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在一个对象中绑定函数，称为这个对象的方法。</p>
<p>在严格模式下，会让对象方法的 <code>this</code> 指向 <code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 28</span></span><br><span class="line"><span class="keyword">var</span> fn = xiaoming.<span class="property">age</span>;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// Uncaught TypeError: Cannot read property &quot;birth&quot; of undefined</span></span><br></pre></td></tr></table></figure>
<p>然而这只是让错误及时暴露出来，并没有解决 <code>this</code> 应该指向的正确位置。</p>
<p>有些时候，会把方法重构一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getAgeFromBirth</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getAgeFromBirth</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// Uncaught TypeError: Cannot read property &quot;birth&quot; of undefined</span></span><br></pre></td></tr></table></figure>
<p>上述报错的原因是 <code>this</code> 指针只在 <code>age()</code> 方法的函数内指向 <code>xiaoming</code>。在函数内部定义的函数，<code>this</code> 又指向 <code>undefined</code> 了（在非严格模式下，它重新指向全局对象 <code>window</code>）。</p>
<p>解决办法是用一个 <code>that</code> 变量首先捕获 <code>this</code>，以避免把所有语句都堆到一个方法中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;            <span class="comment">// 在方法内部一开始就捕获 this</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getAgeFromBirth</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">            <span class="keyword">return</span> y - that.<span class="property">birth</span>;  <span class="comment">// 用 that 而不是 this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getAgeFromBirth</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>要指定函数的 <code>this</code> 指向哪个对象，可以用函数本身的 <code>apply()</code> 方法。它接收两个参数，第一个参数就是需要绑定的 <code>this</code> 变量；第二个参数是数组，表示函数本身的参数。</p>
<p>用 <code>apply()</code> 修复 <code>getAge()</code> 调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getAge</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.<span class="title function_">age</span>();             <span class="comment">// 25</span></span><br><span class="line">getAge.<span class="title function_">apply</span>(xiaoming, []); <span class="comment">// 25。this 指向 xiaoming，参数为空</span></span><br></pre></td></tr></table></figure>
<p>另一个与 <code>apply()</code> 类似的方法是 <code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code> 把参数打包成数组再传入；</li>
<li><code>call()</code> 把参数按顺序传入。</li>
</ul>
<p>比如调用 <code>Math.max(3, 5, 4)</code>，分别用 <code>apply()</code> 和 <code>call()</code> 实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]);    <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>);       <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对普通函数调用，通常把 <code>this</code> 绑定为 <code>null</code>。</p>
</blockquote>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用 <code>apply()</code>，还可以动态改变函数的行为。</p>
<p>JavaScript 的所有对象都是动态的。即使是内置的函数，也可以重新指向新的函数。</p>
<p>现在假定想统计一下代码一共调用了多少次 <code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上 <code>count += 1</code>。不过这样做属于笨办法，最佳方案是用自定义的函数替换掉默认的 <code>parseInt()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parseInt</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;30&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count = &quot;</span> + count); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数指的是接收其它函数作为参数的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(x) + <span class="title function_">f</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">add</span>(-<span class="number">5</span>, <span class="number">6</span>, <span class="title class_">Math</span>.<span class="property">abs</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>举例说明，比如有一个函数 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://math.jianshu.com/math?formula=f(x" alt="f(x)=x^2 ">%3Dx^2 ​)，要把这个函数作用在一个数组 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code> 上，就可以用 <code>map</code> 实现如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-6d323433ab2ce50b.png?imageMogr2/auto-orient/strip|imageView2/2/w/341/format/webp" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qiniu.xiaotao.cloud/9055492-1a641093fce8b748.webp" alt="9055492-1a641093fce8b748"></p>
<p>map 图示</p>
<p>由于 <code>map()</code> 方法定义在 JavaScript 的数组中，调用数组的 <code>map()</code> 方法，传入自定义函数或内置函数，就得到了一个新的数组作为结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.<span class="title function_">map</span>(pow);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>map()</code> 传入的参数是 <code>pow</code>，即函数对象本身。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>数组的 <code>reduce()</code> 把一个函数作用在这个数组的 <code>[x1, x2, x3…]</code> 上，这个函数必须接收两个参数。<code>reduce()</code> 把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x1, x2, x3, x4].<span class="title function_">reduce</span>(f) = <span class="title function_">f</span>(<span class="title function_">f</span>(<span class="title function_">f</span>(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>
<p>比方说对一个数组求和，就可以用 <code>reduce()</code> 实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.<span class="title function_">reduce</span>(add);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h4 id="过滤（filter）"><a href="#过滤（filter）" class="headerlink" title="过滤（filter）"></a>过滤（filter）</h4><p><code>filter</code> 也是一个常用的操作，它用于把数组的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和 <code>map()</code> 类似，数组的 <code>filter()</code> 也接收一个函数。不同的是，<code>filter()</code> 把传入的函数依次作用于每个元素，然后根据返回值是 <code>true</code> 还是 <code>false</code> 决定保留还是丢弃该元素。</p>
<p>例如，在一个数组中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure>
<p>例如，把一个数组中的空字符串删掉，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;  &quot;</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s &amp;&amp; s.<span class="title function_">trim</span>();</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span></span><br></pre></td></tr></table></figure>
<p>可见用 <code>filter()</code> 这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<p><code>filter()</code> 接收的回调函数，其实可以有多个参数。通常仅使用第一个参数，表示数组的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">element, index, self</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// 依次打印 &quot;A&quot;, &quot;B&quot;, &quot;C&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">// 依次打印 0, 1, 2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self); <span class="comment">// self 就是变量 arr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>利用 <code>filter</code>，可以巧妙地去除数组的重复元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    r,</span><br><span class="line">    arr = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;strawberry&quot;</span>];</span><br><span class="line">r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">element, index, self</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">indexOf</span>(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>去除重复元素依靠的是 <code>indexOf()</code> 总是返回同样元素中的第一个的位置，后续的重复元素位置与 <code>indexOf()</code> 返回的位置不相等，因此被 <code>filter</code> 滤掉了。</p>
<h4 id="排序（sort）"><a href="#排序（sort）" class="headerlink" title="排序（sort）"></a>排序（sort）</h4><p>排序也是在程序中经常用到的算法，排序的核心是比较两个元素的大小。</p>
<p>通常规定，对于两个元素 <code>x</code> 和 <code>y</code>：如果认为 <code>x &lt; y</code>，则返回 <code>-1</code>；如果认为 <code>x == y</code>，则返回 <code>0</code>；如果认为 <code>x &gt; y</code>，则返回 <code>1</code>。这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>
<p>JavaScript 数组的 <code>sort()</code> 方法就是用于排序的，但是排序结果可能出乎意料：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看上去正常的结果:</span></span><br><span class="line">[<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Microsoft&quot;</span>].<span class="title function_">sort</span>(); <span class="comment">// [&quot;Apple&quot;, &quot;Google&quot;, &quot;Microsoft&quot;];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apple 排在了最后:</span></span><br><span class="line">[<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Microsoft&quot;</span>].<span class="title function_">sort</span>(); <span class="comment">// [&quot;Google&quot;, &quot;Microsoft&quot;, &quot;apple&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法理解的结果:</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].<span class="title function_">sort</span>(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure>
<p>第二个排序结果是因为字符串根据 ASCII 码进行排序。</p>
<p>第三个排序结果是因为数组的 <strong><code>sort()</code> 方法默认把所有元素先转换为字符串再排序</strong>。</p>
<p>幸运的是，<code>sort()</code> 方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</p>
<p>要按数字大小排序，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，对字符串排序，是按照 ASCII 的大小比较的。若要忽略大小写，可以先把字符串都转成大写（或者都变成小写），再比较。</p>
<blockquote>
<p>需要注意的是，<code>sort()</code> 方法会直接对数组进行修改，它返回的结果仍是当前数组。</p>
</blockquote>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且核心代码可以保持得非常简洁。</p>
<h3 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h3><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>接下来实现一个对数组的求和。通常情况下，求和的函数是这样定义的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>但是，如果不需要立即求和，而是在后面的代码中根据需要再计算的话，可以不返回求和的结果，而是返回求和的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lazy_sum</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 <code>lazy_sum()</code> 时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="title function_">lazy_sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 函数 sum()</span></span><br></pre></td></tr></table></figure>
<p>调用函数 <code>f()</code> 时，才真正计算求和的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，在函数 <code>lazy_sum()</code> 中又定义了函数 <code>sum()</code>，并且内部函数 <code>sum()</code> 可以引用外部函数 <code>lazy_sum()</code> 的参数和局部变量。当 <code>lazy_sum()</code> 返回函数 <code>sum()</code> 时，相关参数和变量都保存在返回的函数中。这种称为“闭包”的程序结构拥有极大的威力。</p>
<p>再注意一点，当调用 <code>lazy_sum()</code> 时，每次调用都会返回一个新的函数，即使传入相同的参数，且调用结果互不影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = <span class="title function_">lazy_sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="title function_">lazy_sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">f1 === f2; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>注意到返回的函数在其定义内部引用了局部变量 <code>arr</code>。所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用。所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了 <code>f()</code> 才执行。看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = <span class="title function_">count</span>();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，每次循环都创建了一个新的函数，然后把创建的三个函数都添加到一个数组中返回了。</p>
<p>可能会认为调用 <code>f1()</code>、<code>f2()</code> 和 <code>f3()</code> 结果应该是 <code>1</code>、<code>4</code>、<code>9</code>，但实际结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 16</span></span><br><span class="line"><span class="title function_">f2</span>(); <span class="comment">// 16</span></span><br><span class="line"><span class="title function_">f3</span>(); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>全是 <code>16</code>。原因就在于返回的函数引用了变量 <code>i</code>，但它并非立刻执行。等到三个函数都返回时，它们所引用的变量 <code>i</code> 已经变成了 <code>4</code>，因此最终结果为 <code>16</code>。</p>
<p>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量</strong>，或者后续会发生变化的变量。</p>
<p>若一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>((<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = <span class="title function_">count</span>();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">f2</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">f3</span>(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>在面向对象的编程语言里，要在对象内部封装一个私有变量，可以用 <code>private</code> 修饰一个成员变量。</p>
<p>在没有 <code>class</code> 机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。用 JavaScript 创建一个计数器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create_counter</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = <span class="title function_">create_counter</span>();</span><br><span class="line">c1.<span class="title function_">inc</span>(); <span class="comment">// 1</span></span><br><span class="line">c1.<span class="title function_">inc</span>(); <span class="comment">// 2</span></span><br><span class="line">c1.<span class="title function_">inc</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="title function_">create_counter</span>(<span class="number">10</span>);</span><br><span class="line">c2.<span class="title function_">inc</span>(); <span class="comment">// 11</span></span><br><span class="line">c2.<span class="title function_">inc</span>(); <span class="comment">// 12</span></span><br><span class="line">c2.<span class="title function_">inc</span>(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量 <code>x</code>，并且从外部代码根本无法访问到变量 <code>x</code>。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qiniu.xiaotao.cloud/math" alt="x^y"> 可以用 <code>Math.pow(x, y)</code> 函数。不过考虑到经常计算 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qiniu.xiaotao.cloud/math" alt="x^2"> 或 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qiniu.xiaotao.cloud/math" alt="x^3">，可以利用闭包创建新的函数 <code>pow2()</code> 和 <code>pow3()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make_pow</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个新函数:</span></span><br><span class="line"><span class="keyword">var</span> pow2 = <span class="title function_">make_pow</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> pow3 = <span class="title function_">make_pow</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pow2</span>(<span class="number">5</span>)); <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pow3</span>(<span class="number">7</span>)); <span class="comment">// 343</span></span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>JavaScript 中，函数可以用箭头语法（=&gt;）定义，又称“Lambda 表达式”。即用类似于如下的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * x;</span><br></pre></td></tr></table></figure>
<p>代替：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连 <code>&#123; … &#125;</code> 和 <code>return</code> 语句都省略掉了。还有一种可以包含多条语句，这时候就不能省略 <code>&#123; … &#125;</code> 和 <code>return</code> 语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数不是一个，就需要用括号 <code>()</code> 括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数：</span></span><br><span class="line">(x, y) =&gt; x * x + y * y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数：</span></span><br><span class="line"><span class="function">() =&gt;</span> <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数：</span></span><br><span class="line"><span class="function">(<span class="params">x, y, ...rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rest.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要返回一个对象，就要注意。如果是单表达式，这么写的话会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="attr">foo</span>: x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为和函数体的 <code>&#123; … &#125;</code> 有语法冲突，所以要改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; (&#123;</span><br><span class="line">    <span class="attr">foo</span>: x</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>箭头函数看上去是匿名函数的一种简写，实际上箭头函数和匿名函数有个明显的区别：箭头函数内部的 <code>this</code> 是词法作用域，由上下文确定。</p>
<p>回顾前面的例子，由于 JavaScript 函数对 <code>this</code> 绑定的错误处理，下面的例子无法得到预期结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this 指向 window 或 undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而箭头函数完全修复了 <code>this</code> 的指向。<code>this</code> 总是指向词法作用域，也就是外层调用者 <code>obj</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this 指向 obj 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>如果使用箭头函数，以前的那种 hack 写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure>
<p>就不再需要了。</p>
<p>由于 <code>this</code> 在箭头函数中已经按照词法作用域绑定了，所以用 <code>call()</code> 或者 <code>apply()</code> 调用箭头函数时，无法对 <code>this</code> 进行绑定，即传入的第一个参数被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params">year</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">fn</span> = (<span class="params">y</span>) =&gt; y - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this.birth 仍是 1990</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">call</span>(&#123; <span class="attr">birth</span>: <span class="number">2000</span> &#125;, year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getAge</span>(<span class="number">2018</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<h3 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h3><p>生成器看上去像是函数，但可以返回多次。</p>
<p>一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果。函数在执行过程中，如果没有遇到 <code>return</code> 语句（函数末尾如果没有 <code>return</code>，就是隐含的 <code>return undefined;</code>），控制权无法交回被调用的代码。</p>
<p>生成器和函数很像，定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成器和函数不同的是，前者由 <code>function*</code> 定义（注意多出的 <code>*</code> 号），并且除了 <code>return</code> 语句，还可以用 <code>yield</code> 返回多次。</p>
<p>以著名的斐波那契数列为例，它由 <code>0, 1</code> 开头：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, ...</span><br></pre></td></tr></table></figure>
<p>要编写一个产生斐波那契数列的函数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="property">length</span> &lt; max) &#123;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        arr.<span class="title function_">push</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">5</span>);     <span class="comment">// [0, 1, 1, 2, 3]</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">10</span>);    <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure>
<p>函数只能返回一次，所以必须返回一个数组。但是，如果换成生成器，就可以一次返回一个数，不断返回多次。用生成器改写如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fib</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fib</span>(<span class="number">5</span>); <span class="comment">// fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125;</span></span><br></pre></td></tr></table></figure>
<p>直接调用一个生成器和调用函数不一样，<code>fib(5)</code> 仅仅是创建了一个生成器对象，还没有去执行它。</p>
<p>调用生成器对象有两个方法，一是不断地调用生成器对象的 <code>next()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="title function_">fib</span>(<span class="number">5</span>);</span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>next()</code> 方法会执行生成器的代码，然后每次遇到 <code>yield x;</code> 就返回一个对象 <code>&#123;value: x, done: true/false&#125;</code>，然后“暂停”。返回的 <code>value</code> 就是 <code>yield</code> 的返回值，<code>done</code> 表示这个生成器是否已经执行结束了。如果 <code>done</code> 为 <code>true</code>，则 <code>value</code> 就是 <code>return</code> 的返回值。</p>
<p>当执行到 <code>done</code> 为 <code>true</code> 时，这个生成器对象就已经全部执行完毕，不要再继续调用 <code>next()</code> 了。</p>
<p>第二个方法是直接用 <code>for … of</code> 循环迭代生成器对象，这种方式不需要自行判断 <code>done</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fib</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> <span class="title function_">fib</span>(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 依次输出 0, 1, 1, 2, 3, …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为生成器可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。利用这一点，写一个生成器就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">n</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">max</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            r = <span class="variable language_">this</span>.<span class="property">a</span>,</span><br><span class="line">            t = <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">b</span> = t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">n</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">n</span> ++;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用对象的属性来保存状态，相当繁琐。</p>
<p>生成器还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了 AJAX 以后才能体会到。</p>
<p>没有生成器之前，用 AJAX 时需要这么写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(<span class="string">&quot;http://url-1&quot;</span>, data1, <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">handle</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&quot;http://url-2&quot;</span>, data2, <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">handle</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&quot;http://url-3&quot;</span>, data3, <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">handle</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">success</span>(result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调越多，代码越难看。</p>
<p>有了生成器之后，用 AJAX 时可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r1 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&quot;http://url-1&quot;</span>, data1);</span><br><span class="line">    r2 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&quot;http://url-2&quot;</span>, data2);</span><br><span class="line">    r3 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&quot;http://url-3&quot;</span>, data3);</span><br><span class="line">    <span class="title function_">success</span>(r3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去是同步的代码，实际执行是异步的。</p>
<h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><p>在 JavaScript 里，一切皆对象。但是这些对象也有不同的类型。为了区分对象的类型，用 <code>typeof</code> 操作符获取对象的类型，它总是返回一个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;str&quot;</span>; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Math</span>.<span class="property">abs</span>; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>除了这些类型外，JavaScript 还提供了包装对象。所谓包装对象，就像 Java 中 <code>int</code> 和 <code>Integer</code> 的关系。</p>
<p>number、boolean 和 string 都有包装对象。包装对象用 <code>new</code> 创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>);   <span class="comment">// 123，生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true，生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>); <span class="comment">// &quot;str&quot;，生成了新的包装类型</span></span><br></pre></td></tr></table></figure>
<p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但类型已经变为 object 了。所以，包装对象和原始值用 <code>===</code> 比较会返回 false：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);   <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);    <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>) === <span class="string">&quot;str&quot;</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>而在没有写 <code>new</code> 的时候，<code>Number()</code>、<code>Boolean()</code> 和 <code>String()</code> 成为普通函数，把任何类型的数据转换为number、boolean 和 string 类型而不是其包装类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="title class_">Number</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123，相当于 parseInt() 或 parseFloat()</span></span><br><span class="line"><span class="keyword">typeof</span> n; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="title class_">Boolean</span>(<span class="string">&quot;false&quot;</span>); <span class="comment">// true。&quot;false&quot; 字符串转换结果为 true，因为它是非空字符串</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="title class_">String</span>(<span class="number">123.45</span>); <span class="comment">// &quot;123.45&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> s; <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>
<p>总结一下，有这么几条规则：</p>
<ul>
<li>不要使用 <code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code> 创建包装对象；</li>
<li>用 <code>parseInt()</code> 或 <code>parseFloat()</code> 来转换任意类型到 number；</li>
<li>用 <code>String()</code> 来转换任意类型到 string，或者直接调用某个对象的 <code>toString()</code> 方法；</li>
<li>通常不必把任意类型转换为 boolean 再判断，因为可以直接写 <code>if (myVar) &#123;…&#125;</code>；</li>
<li><code>typeof</code> 操作符可以判断出 number、boolean、string、function 和 undefined；</li>
<li>判断数组要使用 <code>Array.isArray(arr)</code>；</li>
<li>判断 null 请使用 <code>myVar === null</code>；</li>
<li>判断某个全局变量是否存在用 <code>typeof window.myVar === &quot;undefined&quot;</code>；</li>
<li>函数内部判断某个变量是否存在用 <code>typeof myVar === &quot;undefined&quot;</code>。</li>
</ul>
<p>此外，还有两点需要注意：</p>
<ul>
<li><p>null 和 undefined 没有 <code>toString()</code> 方法；</p>
</li>
<li><p>number 对象调用 <code>toString()</code> 方法时需要以如下格式：</p>
</li>
</ul>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">123</span>).<span class="title function_">toString</span>(); <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>Date 对象表示日期和时间。</p>
<p>要获取系统当前时间，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">now; <span class="comment">// Tue Jul 31 2018 20:08:50 GMT+0800 (中国标准时间)</span></span><br><span class="line">now.<span class="title function_">getFullYear</span>(); <span class="comment">// 2018，年份</span></span><br><span class="line">now.<span class="title function_">getMonth</span>(); <span class="comment">// 6，月份。注意月份范围是 0～11，6 表示七月</span></span><br><span class="line">now.<span class="title function_">getDate</span>(); <span class="comment">// 31，表示 31 号</span></span><br><span class="line">now.<span class="title function_">getDay</span>(); <span class="comment">// 2，表示星期二</span></span><br><span class="line">now.<span class="title function_">getHours</span>(); <span class="comment">// 20，24 小时制</span></span><br><span class="line">now.<span class="title function_">getMinutes</span>(); <span class="comment">// 8，分钟</span></span><br><span class="line">now.<span class="title function_">getSeconds</span>(); <span class="comment">// 50，秒</span></span><br><span class="line">now.<span class="title function_">getMilliseconds</span>(); <span class="comment">// 245，毫秒数</span></span><br><span class="line">now.<span class="title function_">getTime</span>(); <span class="comment">// 1533038930245, 以 number 形式表示的时间戳</span></span><br></pre></td></tr></table></figure>
<p>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。</p>
<blockquote>
<p>时间戳是一个自增的整数，它表示从 1970 年 1 月 1 日零时整的 GMT 时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的。所以，时间戳可以精确地表示一个时刻，并且与时区无关。</p>
</blockquote>
<p>如果要创建一个指定日期和时间的 Date 对象，可以用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Sun Jul 29 2018 12:30:15 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，JavaScript 的 <strong>Date 对象月份值从 0 开始</strong>：0 = 1 月，1 = 2 月，……，11 = 12 月。</p>
<p>第二种创建一个指定日期和时间的方法是解析一个符合 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/NOTE-datetime">ISO 8601</a> 格式的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2018-07-29T12:30:15.123+08:00&quot;</span>);</span><br><span class="line">d; <span class="comment">// 1532838615123</span></span><br></pre></td></tr></table></figure>
<p>但它返回的不是 Date 对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个 Date：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1532838615123</span>);</span><br><span class="line">d; <span class="comment">// Sun Jul 29 2018 12:30:15 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<h4 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h4><p>Date 对象表示的时间总是按浏览器所在时区显示的。不过既可以显示本地时间，也可以显示调整后的 UTC 时间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> k = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1532838615123</span>);</span><br><span class="line">k.<span class="title function_">toLocaleString</span>(); <span class="comment">// &quot;2018/7/29 下午12:30:15&quot;。本地时间（北京时区 +8:00），显示的字符串与操作系统设定的格式有关</span></span><br><span class="line">k.<span class="title function_">toUTCString</span>(); <span class="comment">// &quot;Sun, 29 Jul 2018 04:30:15 GMT&quot;。UTC 时间，与本地时间相差 8 小时</span></span><br></pre></td></tr></table></figure>
<p>时间戳与时区无关。要获取时间戳，可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 1533041129055</span></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式（RegExp）"><a href="#正则表达式（RegExp）" class="headerlink" title="正则表达式（RegExp）"></a>正则表达式（RegExp）</h3><p>JavaScript 有两种方式创建一个正则表达式：</p>
<p>第一种方式是直接通过 <code>/正则表达式/</code> 写出来，第二种方式是通过 <code>new RegExp(&quot;正则表达式&quot;)</code> 创建一个 RegExp 对象。</p>
<p>两种写法是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;ABC\\-001&quot;</span>);</span><br><span class="line"></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure>
<p>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个 <code>\\</code> 实际上是一个 <code>\</code>。</p>
<p>先看看如何判断正则表达式是否匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</span><br><span class="line">re.<span class="title function_">test</span>(<span class="string">&quot;010-12345&quot;</span>); <span class="comment">// true</span></span><br><span class="line">re.<span class="title function_">test</span>(<span class="string">&quot;010-1234x&quot;</span>); <span class="comment">// false</span></span><br><span class="line">re.<span class="title function_">test</span>(<span class="string">&quot;010 12345&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>RegExp 对象的 <code>test()</code> 方法用于测试给定的字符串是否符合条件。</p>
<h4 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h4><p>用正则表达式切分字符串比用固定的字符更灵活。</p>
<p>先看普通的切分代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a b   c&quot;</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>发现无法识别连续的空格。用正则表达式试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a b   c&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/\s+/</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>无论多少个空格都可以正常分割。加入 <code>,</code> 试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a,b, c  d&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/[\s\,]+/</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure>
<p>再加入 <code>;</code> 试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a,b;; c  d&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/[\s\,\;]+/</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure>
<p>实践证明，可以使用正则表达式来把不规范的输入转化成正确的数组。</p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用 <code>()</code> 表示的就是要提取的分组（group）。比如：</p>
<p><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code> 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&quot;010-12345&quot;</span>); <span class="comment">// [&quot;010-12345&quot;, &quot;010&quot;, &quot;12345&quot;]</span></span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&quot;010 12345&quot;</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在 RegExp 对象上用 <code>exec()</code> 方法提取出子串来：</p>
<ul>
<li><code>exec()</code> 方法在匹配成功后，会返回一个数组。第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</li>
<li><code>exec()</code> 方法在匹配失败时返回 null。</li>
</ul>
<p>提取子串非常有用。来看一个更厉害的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&quot;19:05:30&quot;</span>); <span class="comment">// [&quot;19:05:30&quot;, &quot;19&quot;, &quot;05&quot;, &quot;30&quot;]</span></span><br></pre></td></tr></table></figure>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/</span>;</span><br></pre></td></tr></table></figure>
<p>对于 <code>&quot;2-30&quot;</code>，<code>&quot;4-31&quot;</code> 这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<h4 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h4><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的 <code>0</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&quot;102300&quot;</span>); <span class="comment">// [&quot;102300&quot;, &quot;102300&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>\d+</code> 采用贪婪匹配，直接把后面的 <code>0</code> 全部匹配了，结果 <code>0*</code> 只能匹配空字符串了。</p>
<p>这时需要让 <code>\d+</code> 采用非贪婪匹配（也就是尽可能少匹配），才能把后面的 <code>0</code> 匹配出来，加个 <code>?</code> 就可以让 <code>\d+</code> 采用非贪婪匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&quot;102300&quot;</span>); <span class="comment">// [&quot;102300&quot;, &quot;1023&quot;, &quot;00&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h4><p>JavaScript 的正则表达式还有几个特殊的标志，最常用的是 <code>g</code>，表示全局匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>全局匹配可以多次执行 <code>exec()</code> 方法来搜索一个匹配的字符串。当指定 <code>g</code> 标志后，每次运行 <code>exec()</code>，正则表达式本身会更新 <code>lastIndex</code> 属性，表示上次匹配到的最后索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;JavaScript, VBScript, JScript and ECMAScript&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配：</span></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&quot;JavaScript&quot;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&quot;VBScript&quot;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&quot;JScript&quot;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&quot;ECMAScript&quot;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure>
<p>全局匹配类似搜索，因此不能使用 <code>/^…$/</code>，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定 <code>i</code> 标志，表示忽略大小写；<code>m</code> 标志，表示执行多行匹配。</p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>与 Java、C# 等不同，JavaScript 不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>
<p>假设现在要创建 <code>xiaoming</code> 这个具体的学生。而且有一个现成的 <code>Student</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Student</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Robot&quot;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.2</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is running…&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么就直接拿来创建 <code>xiaoming</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(xiaoming, <span class="title class_">Student</span>);</span><br></pre></td></tr></table></figure>
<p>注意最后一行代码把 <code>xiaoming</code> 的原型指向了对象 <code>Student</code>，看上去 <code>xiaoming</code> 仿佛是从 <code>Student</code> 继承下来的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.<span class="property">name</span>;  <span class="comment">// &quot;小明&quot;</span></span><br><span class="line">xiaoming.<span class="title function_">run</span>(); <span class="comment">// 小明 is running…</span></span><br></pre></td></tr></table></figure>
<p><code>xiaoming</code> 有自己的 <code>name</code> 属性，但并没有定义 <code>run()</code> 方法。不过，由于小明是从 <code>Student</code> 继承而来，只要 <code>Student</code> 有 <code>run()</code> 方法，<code>xiaoming</code> 也可以调用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-c9510e7225961583.png?imageMogr2/auto-orient/strip|imageView2/2/w/423/format/webp" alt="img"></p>
<p>xiaoming 与其原型 Student 的关系</p>
<p>JavaScript 的原型链和 Java、C# 中的类的区别就在于，它没有”类“的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p>
<p>如果把 <code>xiaoming</code> 的原型指向其他对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Bird</span> = &#123;</span><br><span class="line">    <span class="attr">fly</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is flying…&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(xiaoming, <span class="title class_">Bird</span>);</span><br></pre></td></tr></table></figure>
<p>现在 <code>xiaoming</code> 已经无法 <code>run()</code> 了，他已经变成了一只鸟：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.<span class="title function_">fly</span>(); <span class="comment">// 小明 is flying…</span></span><br></pre></td></tr></table></figure>
<p>在 JavaScript 代码运行时期，可以把 <code>xiaoming</code> 从 <code>Student</code> 变成 <code>Bird</code>，或者变成任何对象。</p>
<p>请注意，上述代码仅用于演示目的。在编写 JavaScript 代码时，不要直接用 <code>Object.setPrototypeOf()</code> 去改变一个对象的原型。</p>
<p><code>Object.create()</code> 方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此可以编写一个函数来创建 <code>xiaoming</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Student</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Robot&quot;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.2</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is running…&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createStudent</span>(<span class="params">iniName</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Student</span>); <span class="comment">// 基于 Student 原型创建一个新对象</span></span><br><span class="line">    s.<span class="property">name</span> = iniName; <span class="comment">// 初始化新对象</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="title function_">createStudent</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">xiaoming.<span class="title function_">run</span>(); <span class="comment">// 小明 is running…</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(xiaoming) === <span class="title class_">Student</span>;</span><br></pre></td></tr></table></figure>
<p>这是创建原型继承的一种方法，JavaScript 还有其他方法来创建对象。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>JavaScript 对每个创建的对象都会设置一个原型，指向它的原型对象。</p>
<p>当用 <code>obj.xxx</code> 访问一个对象的属性时，JavaScript 引擎先在当前对象上查找该属性。如果没有找到，就到其原型对象上找；如果还没有找到，就一直上溯到 <code>Object.prototype</code> 对象；最后如果还没有找到，就只能返回 <code>undefined</code>。</p>
<p>例如，创建一个数组对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>其原型链是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr --&gt; <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p><code>Array.prototype</code> 定义了 <code>indexOf()</code>、<code>shift()</code> 等方法，因此可以在所有的数组对象上直接调用这些方法。</p>
<p>当创建一个函数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数也是一个对象，它的原型链是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo --&gt; <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>Function.prototype</code> 定义了 <code>apply()</code> 等方法，因此所有函数都可以调用 <code>apply()</code> 方法。</p>
<p>很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>除了直接用 <code>&#123; … &#125;</code> 创建一个对象外，JavaScript 还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用关键字 <code>new</code> 来调用这个函数，并返回一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">xiaoming.<span class="property">name</span>; <span class="comment">// &quot;小明&quot;</span></span><br><span class="line">xiaoming.<span class="title function_">hello</span>(); <span class="comment">// Hello, 小明!</span></span><br></pre></td></tr></table></figure>
<p>注意，如果不写 <code>new</code>，这就是一个普通函数，它返回 <code>undefined</code>。但是，如果写了 <code>new</code>，它就变成了一个构造函数，它绑定的 <code>this</code> 指向新创建的对象，并默认返回 <code>this</code>，因此不需要在最后写 <code>return this;</code>。</p>
<p>新创建的 <code>xiaoming</code> 的原型链是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming --&gt; <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>也就是说，<code>xiaoming</code> 的原型指向函数 <code>Student</code> 的原型。如果又创建了 <code>xiaohong</code>、<code>xiaojun</code>，那么这些对象的原型与 <code>xiaoming</code> 是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming ↘</span><br><span class="line">xiaohong -→ <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br><span class="line">xiaojun  ↗</span><br></pre></td></tr></table></figure>
<p>用 <code>new Student()</code> 创建的对象还从原型上获得了一个 <code>constructor</code> 属性，它指向函数 <code>Student</code> 本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.<span class="property">constructor</span> === <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Student</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(xiaoming) === <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> <span class="title class_">Student</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面这些关系可以表示为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-03e0a9db3aa01063.png?imageMogr2/auto-orient/strip|imageView2/2/w/632/format/webp" alt="img"></p>
<p>xiaoming、Student 及 Object 的关系</p>
<p>红色箭头是原型链。注意，<code>Student.prototype</code> 指向的对象就是 <code>xiaoming</code>、<code>xiaohong</code> 的原型对象，这个原型对象自己还有个属性 <code>constructor</code>，指向 <code>Student</code> 函数本身。</p>
<p>另外，函数 <code>Student</code> 恰好有个属性 <code>prototype</code> 指向 <code>xiaoming</code>、<code>xiaohong</code> 的原型对象，但是 <code>xiaoming</code>、<code>xiaohong</code> 这些对象可没有 <code>prototype</code> 这个属性，不过可以用 <code>Object.getPrototypeOf()</code> 来查看。</p>
<p>现在就认为 <code>xiaoming</code>、<code>xiaohong</code> 这些对象“继承”自 <code>Student</code>。</p>
<p>注意，<code>xiaoming</code> 和 <code>xiaohong</code> 各自的 <code>hello()</code> 是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的。</p>
<p>如果通过 <code>new Student()</code> 创建了很多对象，这些对象的 <code>hello()</code> 函数实际上只需要共享同一个函数就可以了，这样可以节省很多空间。</p>
<p>要让创建的对象共享一个 <code>hello()</code> 函数，根据对象的属性查找原则，只要把 <code>hello()</code> 函数移动到 <code>xiaoming</code>、<code>xiaohong</code> 这些对象共同的原型上就可以了，也就是 <code>Student.prototype</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-5c2b644f1966dbe1.png?imageMogr2/auto-orient/strip|imageView2/2/w/634/format/webp" alt="img"></p>
<p>xiaoming、Student 及 Object 的关系与 hello() 函数</p>
<p>修改代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用 <code>new</code> 创建基于原型的 JavaScript 的对象就是这样。</p>
<h4 id="缺少-new-的构造函数"><a href="#缺少-new-的构造函数" class="headerlink" title="缺少 new 的构造函数"></a>缺少 new 的构造函数</h4><p>构造函数在调用时若缺少 <code>new</code>，会出现错误。</p>
<p>如，在严格模式下，<code>this.name = name</code> 将报错，因为 <code>this</code> 绑定为 <code>undefined</code>；在非严格模式下，<code>this.name = name</code> 不报错，因为 <code>this</code> 绑定为 <code>window</code>，于是无意间创建了全局变量 <code>name</code>，并且返回 <code>undefined</code>，这个结果更糟糕。</p>
<p>习惯上，构造函数首字母应当大写，而普通函数首字母应当小写。这样，一些语法检查工具如 <a target="_blank" rel="noopener" href="https://www.jslint.com/">JSLint</a> 将可以检测到漏写的 <code>new</code>。</p>
<p>最后，还可以编写一个 <code>createStudent()</code> 函数，在内部封装所有的 <code>new</code> 操作。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = props.<span class="property">name</span> || <span class="string">&quot;匿名&quot;</span>; <span class="comment">// 默认值为“匿名”</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">grade</span> = props.<span class="property">grade</span> || <span class="number">1</span>; <span class="comment">// 默认值为 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createStudent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(props || &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>createStudent()</code> 函数的优点在于：一是不需要 <code>new</code> 来调用；二是参数非常灵活，可以不传，也可以这么传：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = <span class="title function_">createStudent</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="property">grade</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>如果创建的对象有很多属性，只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个 Object，无需记忆参数的顺序。如果恰好从 JSON 拿到了一个对象，就可以直接创建出 <code>xiaoming</code>。</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>在基于类的面向对象编程语言中，继承的本质是扩展一个已有的类，并生成新的派生类。</p>
<p>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript 由于采用原型继承，无法直接扩展一个类，因为根本不存在类这种类型。</p>
<p>先回顾 <code>Student</code> 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = props.<span class="property">name</span> || <span class="string">&quot;Unnamed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以及 <code>Student</code> 的原型链：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-07c4b6abb036c45c.png?imageMogr2/auto-orient/strip|imageView2/2/w/634/format/webp" alt="img"></p>
<p>Student 的原型链</p>
<p>现在，要基于 <code>Student</code> 扩展出 <code>PrimaryStudent</code>，可以先定义出 <code>PrimaryStudent</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PrimaryStudent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 Student 构造函数，绑定 this 变量:</span></span><br><span class="line">    <span class="title class_">Student</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">grade</span> = props.<span class="property">grade</span> || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，调用了 <code>Student</code> 构造函数不等于继承了 <code>Student</code>。<code>PrimaryStudent</code> 创建的对象的原型是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>() --&gt; <span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>必须想办法把原型链修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>() --&gt; <span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>这样，原型链对了，继承关系就对了。新的基于 <code>PrimaryStudent</code> 创建的对象不但能调用 <code>PrimaryStudent.prototype</code> 定义的方法，也可以调用 <code>Student.prototype</code> 定义的方法。</p>
<p>对此，可以使用 <code>Object.create()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">PrimaryStudent</span>;</span><br></pre></td></tr></table></figure>
<p>验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 xiaoming</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">grade</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="property">name</span>; <span class="comment">// &quot;小明&quot;</span></span><br><span class="line">xiaoming.<span class="property">grade</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型：</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(xiaoming) === <span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(xiaoming)) === <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系：</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> <span class="title class_">PrimaryStudent</span>; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> <span class="title class_">Student</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h3><p>class 的目的就是让定义类更简单。</p>
<p>先回顾用函数实现 <code>Student</code> 的方法：</p>
<p>、</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用 class 来编写，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较一下就可以发现，class 的定义包含了构造函数 <code>constructor</code> 和定义在原型对象上的函数 <code>hello()</code>（注意没有 <code>function</code> 关键字），这样就避免了 <code>Student.prototype.hello = function () &#123; … &#125;</code> 这样分散的代码。</p>
<p>最后，创建一个 <code>Student</code> 对象的代码则完全一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">xiaoming.<span class="title function_">hello</span>();</span><br></pre></td></tr></table></figure>
<p>用 class 定义对象的另一个好处是继承更方便了，直接通过 <code>extends</code> 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Student</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name); <span class="comment">// 记得用 super() 调用基类的构造方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">myGrade</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;I am at grade &quot;</span> + <span class="variable language_">this</span>.<span class="property">grade</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>PrimaryStudent</code> 的定义也是 class 实现的，而 <code>extends</code> 则表示原型链对象来自 <code>Student</code>。</p>
<p>派生类的构造方法可能会与基类不太相同。例如，<code>PrimaryStudent</code> 需要 <code>name</code> 和 <code>grade</code> 两个参数，并且需要通过 <code>super(name)</code> 来调用基类的构造函数，否则基类的 <code>name</code> 属性无法正常初始化。</p>
<p><code>PrimaryStudent</code> 自动获得了基类 <code>Student</code> 的 <code>hello()</code> 方法，其又定义了新的 <code>myGrade()</code> 方法。</p>
<blockquote>
<p>需要明确的是，class 仅仅是语法糖，JavaScript 依然是基于原型的。</p>
</blockquote>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h3><p>JavaScript 可以获取浏览器提供的很多对象，并进行操作。</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p><code>window</code> 对象不但充当全局作用域，而且表示浏览器窗口。</p>
<p><code>window</code> 对象有 <code>innerWidth</code> 和 <code>innerHeight</code> 属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高，包括滚动条在内。</p>
<p>对应的，还有一个 <code>outerWidth</code> 和 <code>outerHeight</code> 属性，可以获取浏览器窗口的整个宽高。</p>
<blockquote>
<p>兼容性：IE8 及以下不支持。</p>
</blockquote>
<h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><p><code>navigator</code> 对象表示浏览器的信息，最常用的属性包括：</p>
<ul>
<li><code>navigator.appName</code>：浏览器名称；</li>
<li><code>navigator.appVersion</code>：浏览器版本；</li>
<li><code>navigator.language</code>：浏览器设置的语言；</li>
<li><code>navigator.platform</code>：操作系统类型；</li>
<li><code>navigator.userAgent</code>：浏览器设定的用户代理字符串。</li>
</ul>
<p>请注意，<code>navigator</code> 的信息可以很容易地被用户修改，所以 JavaScript 读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用 <code>if</code> 判断浏览器版本，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">getIEVersion</span>(navigator.<span class="property">userAgent</span>) &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    width = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    width = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用 JavaScript 对不存在属性返回 <code>undefined</code> 的特性，直接用短路运算符 <code>||</code> 计算：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br></pre></td></tr></table></figure>
<h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><p><code>screen</code> 对象表示屏幕的信息，常用的属性有：</p>
<ul>
<li><code>screen.width</code>：屏幕宽度，以像素为单位；</li>
<li><code>screen.height</code>：屏幕高度，以像素为单位；</li>
<li><code>screen.colorDepth</code>：颜色深度，如 8、16、24。根据 CSS 对象模型视图，为兼容起见，该值总为 24。</li>
</ul>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p><code>location</code> 对象表示当前页面的 URL 信息。例如，一个完整的 URL：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span></span><br></pre></td></tr></table></figure>
<p>可以用 <code>location.href</code> 获取。要获得 URL 各个部分的值，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="property">protocol</span>; <span class="comment">// &quot;http&quot;</span></span><br><span class="line">location.<span class="property">host</span>; <span class="comment">// &quot;www.example.com&quot;</span></span><br><span class="line">location.<span class="property">port</span>; <span class="comment">// &quot;8080&quot;</span></span><br><span class="line">location.<span class="property">pathname</span>; <span class="comment">// &quot;/path/index.html&quot;</span></span><br><span class="line">location.<span class="property">search</span>; <span class="comment">// &quot;?a=1&amp;b=2&quot;</span></span><br><span class="line">location.<span class="property">hash</span>; <span class="comment">// &quot;TOP&quot;</span></span><br></pre></td></tr></table></figure>
<p>要加载一个新页面，可以调用 <code>location.assign()</code>。如果要重新加载当前页面，调用 <code>location.reload()</code> 方法非常方便。</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p><code>document</code> 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，<code>document</code> 对象就是整个 DOM 树的根节点。</p>
<p><code>document</code> 的 <code>title</code> 属性是从 HTML 文档中的 <code>&lt;title&gt;xxx&lt;/title&gt;</code> 读取的，但是可以动态改变。</p>
<p>要查找 DOM 树的某个节点，需要从 <code>document</code> 对象开始查找。最常用的查找是根据 ID 和 Tag Name。</p>
<p>先准备 HTML 数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">id</span>=<span class="string">&quot;drink-menu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:solid 1px #ccc;padding:6px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>摩卡<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>热摩卡咖啡<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>酸奶<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>北京老酸奶<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>果汁<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>鲜榨苹果汁<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用 <code>document</code> 对象提供的 <code>getElementById()</code> 和 <code>getElementsByTagName()</code> 可以按 ID 获得一个 DOM 节点和按 Tag 名称获得一组 DOM 节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drink-menu&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> drinks = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;dt&quot;</span>);</span><br><span class="line"></span><br><span class="line">menu.<span class="property">tagName</span>; <span class="comment">// &quot;DL&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;提供的饮料有：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; drinks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    s += drinks[i].<span class="property">innerHTML</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= drinks.<span class="property">length</span> - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    s += <span class="string">&quot;、&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供的饮料有：摩卡，酸奶，果汁</span><br></pre></td></tr></table></figure>
<p><code>document</code> 对象还有一个 <code>cookie</code> 属性，可以获取当前页面的 Cookie。</p>
<blockquote>
<p>由于 JavaScript 能读取到页面的 Cookie，而用户的登录信息通常也存在 Cookie 中，这就造成了巨大的安全隐患。为了解决这个问题，服务器在设置 Cookie 时可以使用 <code>httpOnly</code>，设定了 <code>httpOnly</code> 的 Cookie 将不能被 JavaScript 读取。</p>
</blockquote>
<h3 id="操作-DOM"><a href="#操作-DOM" class="headerlink" title="操作 DOM"></a>操作 DOM</h3><p>由于 HTML 文档被浏览器解析后就是一棵 DOM 树，要改变 HTML 的结构，就需要通过 JavaScript 来操作 DOM。</p>
<p>始终记住 DOM 是一个树形结构。操作一个 DOM 节点实际上就是这么几个操作：</p>
<ul>
<li>更新：更新该 DOM 节点的内容，相当于更新了该 DOM 节点表示的 HTML 的内容；</li>
<li>遍历：遍历该 DOM 节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该 DOM 节点下新增一个子节点，相当于动态增加了一个 HTML 节点；</li>
<li>删除：将该节点从 HTML 中删除，相当于删掉了该 DOM 节点的内容以及它包含的所有子节点。</li>
</ul>
<p>在操作一个 DOM 节点前，需要通过各种方式先获取这个 DOM 节点。最常用的方法是 <code>document.getElementById()</code> 和 <code>document.getElementsByTagName()</code>，以及 CSS 选择器 <code>document.getElementsByClassName()</code>。</p>
<p>由于 ID 在 HTML 文档中是唯一的，所以 <code>document.getElementById()</code> 可以直接定位唯一的一个 DOM 节点。<code>document.getElementsByTagName()</code> 和 <code>document.getElementsByClassName()</code>总是返回一组 DOM 节点。要精确地选择 DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 ID 为“test”的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位 ID 为“test-table”的节点，再返回其内部所有 tr 节点：</span></span><br><span class="line"><span class="keyword">var</span> trs = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-table&quot;</span>).<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位 ID 为“test-div”的节点，再返回其内部所有 class 包含 red 的节点：</span></span><br><span class="line"><span class="keyword">var</span> reds = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-div&quot;</span>).<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点 test 下的所有直属子节点：</span></span><br><span class="line"><span class="keyword">var</span> cs = test.<span class="property">children</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点 test 下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">var</span> first = test.<span class="property">firstElementChild</span>;</span><br><span class="line"><span class="keyword">var</span> last = test.<span class="property">lastElementChild</span>;</span><br></pre></td></tr></table></figure>
<p>第二种方法是使用 <code>querySelector()</code> 和 <code>querySelectorAll()</code>，需要了解 selector 语法，然后使用条件来获取节点，更加方便：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 querySelector 获取 ID 为 q1 的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#q1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 querySelectorAll 获取 q1 节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">var</span> ps = q1.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div.highlighted &gt; p&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，IE8 以下版本不支持 <code>querySelector</code> 和 <code>querySelectorAll</code>。IE8 仅有限支持。</p>
</blockquote>
<p>严格地讲，这里的 DOM 节点是指 <code>Element</code>，但是 DOM 节点实际上是 <code>Node</code>。在 HTML 中，<code>Node</code> 包括<code>Element</code>、<code>Comment</code>、<code>CDATA_SECTION</code> 等很多种，以及根节点 <code>Document</code> 类型。但是，绝大多数时候只关心 <code>Element</code>，也就是实际控制页面结构的 <code>Node</code>，其他类型的 <code>Node</code> 忽略即可。根节点 <code>Document</code> 已经自动绑定为全局变量 <code>document</code>。</p>
<h4 id="更新-DOM"><a href="#更新-DOM" class="headerlink" title="更新 DOM"></a>更新 DOM</h4><p>拿到一个 DOM 节点后，可以对它进行更新。</p>
<p>可以直接修改节点的文本，方法有两种。</p>
<p>一种是修改 <code>innerHTML</code> 属性，这个方式非常强大，不但可以修改一个 DOM 节点的文本内容，还可以直接通过 HTML 片段修改 DOM 节点内部的子树：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 &lt;p id=&quot;p-id&quot;&gt;…&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p-id&quot;</span>);</span><br><span class="line"><span class="comment">// 设置文本为 abc：</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置 HTML：</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&quot;ABC &lt;span style=\&quot;color:red\&quot;&gt;RED&lt;/span&gt; XYZ&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;…&lt;/p&gt; 的内部结构已修改</span></span><br></pre></td></tr></table></figure>
<p>用 <code>innerHTML</code> 时要注意，是否需要写入 HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免 XSS 攻击。</p>
<p>第二种是修改 <code>innerText</code> 或 <code>textContent</code> 属性，这样可以自动对字符串进行 HTML 编码，保证无法设置任何 HTML 标签：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 &lt;p id=&quot;p-id&quot;&gt;…&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p-id&quot;</span>);</span><br><span class="line"><span class="comment">// 设置文本：</span></span><br><span class="line">p.<span class="property">innerText</span> = <span class="string">&quot;&lt;script&gt;alert(\&quot;Hi\&quot;);&lt;/script&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// HTML 被自动编码，无法设置一个 &lt;script&gt; 节点：</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;);&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>两者的区别在于读取属性时，<code>innerText</code> 不返回隐藏元素的文本，而 <code>textContent</code> 返回所有文本。</p>
<blockquote>
<p>另外注意 IE9 以下不支持 <code>textContent</code>。</p>
</blockquote>
<p>修改 CSS 也是经常需要的操作。DOM 节点的 <code>style</code> 属性对应所有的 CSS，可以直接获取或设置。</p>
<p>因为 CSS 允许 <code>font-size</code> 这样的名称，但它并非 JavaScript 有效的属性名，所以需要在 JavaScript 中改写为驼峰式命名 <code>fontSize</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 &lt;p id=&quot;p-id&quot;&gt;…&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p-id&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 CSS：</span></span><br><span class="line">p.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">p.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;20px&quot;</span>;</span><br><span class="line">p.<span class="property">style</span>.<span class="property">paddingTop</span> = <span class="string">&quot;2em&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="插入-DOM"><a href="#插入-DOM" class="headerlink" title="插入 DOM"></a>插入 DOM</h4><p>当获得了某个 DOM 节点，想在这个 DOM 节点内插入新的 DOM，应该怎么做？</p>
<p>如果这个 DOM 节点是空的，例如 <code>&lt;div&gt;&lt;/div&gt;</code>，那么直接使用 <code>innerHTML = &quot;&lt;span&gt;child&lt;/span&gt;&quot;</code> 就可以修改 DOM 节点的内容，相当于“插入”了新的 DOM 节点。</p>
<p>如果这个 DOM 节点不是空的，那就不能这么做，因为修改 <code>innerHTML</code> 会直接替换掉原来的所有子节点。</p>
<p>有两个办法可以插入新的节点。一个是使用 <code>appendChild()</code>，把一个子节点添加到父节点的最后一个子节点。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把 <code>&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;</code> 添加到 <code>&lt;div id=&quot;list&quot;&gt;</code> 的最后一项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    js = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;js&quot;</span>),</span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">list.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure>
<p>现在，HTML 结构变成了这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为插入的 <code>js</code> 节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。</p>
<p>更多的时候会从零创建一个新的节点，然后追加到指定位置之后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;list&quot;</span>),</span><br><span class="line">    haskell = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">haskell.<span class="property">id</span> = <span class="string">&quot;haskell&quot;</span>;</span><br><span class="line">haskell.<span class="property">innerText</span> = <span class="string">&quot;Haskell&quot;</span>;</span><br><span class="line">list.<span class="title function_">appendChild</span>(haskell);</span><br></pre></td></tr></table></figure>
<p>这样就动态添加了一个新的节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;haskell&quot;</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>动态创建一个节点然后添加到 DOM 树中，可以实现很多功能。举个例子，下面的代码动态创建了一个 <code>&lt;style&gt;</code> 节点，然后把它添加到 <code>&lt;head&gt;</code> 节点的末尾，这样就动态地给文档添加了新的 CSS 定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">d.<span class="title function_">setAttribute</span>(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text/css&quot;</span>);</span><br><span class="line">d.<span class="property">innerHTML</span> = <span class="string">&quot;p &#123; color: red &#125;&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(d);</span><br></pre></td></tr></table></figure>
<p>可以在浏览器的开发者工具中执行上述代码，观察页面样式的变化。</p>
<h5 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h5><p>如果要把子节点插入到指定的位置，可以使用 <code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到 <code>referenceElement</code> 之前。</p>
<p>还是以上面的 HTML 为例，假定要把 <code>Haskell</code> 插入到 <code>Python</code> 之前：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;list&quot;</span>),</span><br><span class="line">    ref = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;python&quot;</span>),</span><br><span class="line">    haskell = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">haskell.<span class="property">id</span> = <span class="string">&quot;haskell&quot;</span>;</span><br><span class="line">haskell.<span class="property">innerText</span> = <span class="string">&quot;Haskell&quot;</span>;</span><br><span class="line">list.<span class="title function_">insertBefore</span>(haskell, ref);</span><br></pre></td></tr></table></figure>
<p>新的 HTML 结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;haskell&quot;</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可见，使用 <code>insertBefore</code> 的重点是要获得一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代<code>children</code>属性实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    i, c,</span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.<span class="property">children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    c = list.<span class="property">children</span>[i]; <span class="comment">// 获得第 i 个子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除-DOM"><a href="#删除-DOM" class="headerlink" title="删除 DOM"></a>删除 DOM</h4><p>删除一个 DOM 节点就比插入要容易得多。</p>
<p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后调用父节点的 <code>removeChild()</code> 把自己删掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得待删除节点：</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;to-be-removed&quot;</span>);</span><br><span class="line"><span class="comment">// 获得父节点：</span></span><br><span class="line"><span class="keyword">var</span> parent = self.<span class="property">parentElement</span>;</span><br><span class="line"><span class="comment">// 删除：</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.<span class="title function_">removeChild</span>(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p>
<p>当遍历一个父节点的子节点并进行删除操作时，要注意 <code>children</code> 属性是一个只读属性，并且它在子节点变化时会实时更新。</p>
<p>例如，对于如下 HTML 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>First<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用如下代码删除子节点时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">parent.<span class="title function_">removeChild</span>(parent.<span class="property">children</span>[<span class="number">0</span>]);</span><br><span class="line">parent.<span class="title function_">removeChild</span>(parent.<span class="property">children</span>[<span class="number">1</span>]); <span class="comment">// ← 浏览器报错</span></span><br></pre></td></tr></table></figure>
<p>浏览器报错：<code>parent.children[1]</code> 不是一个有效的节点。原因就在于，当 <code>&lt;p&gt;First&lt;/p&gt;</code> 节点被删除后，<code>parent.children</code> 的节点数量已经从 2 变为了 1，索引 <code>[1]</code> 已经不存在了。</p>
<p>因此，删除多个节点时，要注意 <code>children</code> 属性时刻都在变化。</p>
<h3 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h3><p>用 JavaScript 操作表单和操作 DOM 是类似的，因为表单本身也是 DOM 树。</p>
<p>不过表单的输入框、下拉框等可以接收用户输入，所以用 JavaScript 来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p>
<p>HTML 表单的输入控件主要有以下几种：</p>
<ul>
<li>文本框，对应的 <code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li>
<li>口令框，对应的 <code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li>
<li>单选框，对应的 <code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li>
<li>复选框，对应的 <code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li>
<li>下拉框，对应的 <code>&lt;select&gt;</code>，用于选择一项；</li>
<li>隐藏文本，对应的 <code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li>
</ul>
<h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><p>如果获得了一个 <code>&lt;input&gt;</code> 节点的引用，就可以直接调用 <code>value</code> 获得对应的用户输入值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">input.<span class="property">value</span>; <span class="comment">// &quot;用户输入的值&quot;</span></span><br></pre></td></tr></table></figure>
<p>这种方式可以应用于 <code>text</code>、<code>password</code>、<code>hidden</code> 以及 <code>select</code>。但是，对于单选框和复选框，<code>value</code> 属性返回的是 HTML 预设的值，而需要获得的实际是用户是否“勾上了”选项，所以应该用 <code>checked</code> 判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt;Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt;Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;monday&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tuesday&quot;</span>);</span><br><span class="line">mon.<span class="property">value</span>; <span class="comment">// &quot;1&quot;</span></span><br><span class="line">tue.<span class="property">value</span>; <span class="comment">// &quot;2&quot;</span></span><br><span class="line">mon.<span class="property">checked</span>; <span class="comment">// true 或者 false</span></span><br><span class="line">tue.<span class="property">checked</span>; <span class="comment">// true 或者 false</span></span><br></pre></td></tr></table></figure>
<h4 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h4><p>设置值和获取值类似，对于 <code>text</code>、<code>password</code>、<code>hidden</code> 以及 <code>select</code>，直接设置 <code>value</code> 就可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">input.<span class="property">value</span> = <span class="string">&quot;test@example.com&quot;</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure>
<p>对于单选框和复选框，设置 <code>checked</code> 为 true 或 false 即可。</p>
<h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><p>方式一是通过 <code>&lt;form&gt;</code> 元素的 <code>submit()</code> 方法提交一个表单。例如，响应一个 <code>&lt;button&gt;</code> 的 <code>click</code> 事件，在 JavaScript 代码中提交表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;doSubmitForm()&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">doSubmitForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-form&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 可以在此修改 form 的 input…</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 提交 form：</span></span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式的缺点是扰乱了浏览器对 form 的正常提交。浏览器默认点击 <code>&lt;button type=&quot;submit&quot;&gt;</code> 时提交表单，或者用户在最后一个输入框按回车键。</p>
<p>因此，第二种方式是响应 <code>&lt;form&gt;</code> 本身的 <code>onsubmit</code> 事件，在提交 form 时作修改：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-form&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 可以在此修改 form 的 input…</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 继续下一步：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意要 <code>return true;</code> 来告诉浏览器继续提交。如果 <code>return false;</code>，浏览器将不会继续提交 form，这种情况通常对应于用户输入有误，提示用户错误信息后终止提交 form。</p>
<p>在检查和修改 <code>&lt;input&gt;</code> 时，要充分利用 <code>&lt;input type=&quot;hidden&quot;&gt;</code> 来传递数据。例如，很多登录表单希望用户输入用户名和口令，但出于安全考虑，提交表单时不传输明文口令，而是口令的 MD5。普通 JavaScript 开发人员会直接修改 <code>&lt;input&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> pwd = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 把用户输入的明文变为 MD5：</span></span></span><br><span class="line"><span class="language-javascript">    pwd.<span class="property">value</span> = <span class="title function_">toMD5</span>(pwd.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 继续下一步：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个做法看上去没什么问题，但用户输入了口令提交时，口令框的显示会突然从几个 <code>*</code> 变成 32 个 <code>*</code>（MD5 有 32 个字符）。要想不改变用户的输入，可以利用 <code>&lt;input type=&quot;hidden&quot;&gt;</code> 实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input-password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">id</span>=<span class="string">&quot;md5-password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> input_pwd = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input-password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> md5_pwd = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;md5-password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 把用户输入的明文变为 MD5：</span></span></span><br><span class="line"><span class="language-javascript">    md5_pwd.<span class="property">value</span> = <span class="title function_">toMD5</span>(input_pwd.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 继续下一步：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到 <code>id</code> 为 <code>md5-password</code> 的 <code>&lt;input&gt;</code> 标记了 <code>name=&quot;password&quot;</code>，而用户输入的 <code>id</code> 为 <code>input-password</code> 的 <code>&lt;input&gt;</code> 没有 <code>name</code> 属性。没有 <code>name</code> 属性的 <code>&lt;input&gt;</code> 的数据不会被提交。</p>
<h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>在 HTML 表单中，可以上传文件的唯一控件就是 <code>&lt;input type=&quot;file&quot;&gt;</code>。</p>
<p>注意：当一个表单包含 <code>&lt;input type=&quot;file&quot;&gt;</code> 时，表单的 <code>enctype</code> 必须指定为 <code>multipart/form-data</code>，<code>method</code> 必须指定为 <code>post</code>，浏览器才能正确编码并以 <code>multipart/form-data</code> 格式发送表单的数据。</p>
<p>出于安全考虑，浏览器只允许用户点击 <code>&lt;input type=&quot;file&quot;&gt;</code> 来选择本地文件，用 JavaScript 对 <code>&lt;input type=&quot;file&quot;&gt;</code> 的 <code>value</code> 赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript 也无法获得该文件的真实路径。</p>
<p>通常，上传的文件都由后台服务器处理，JavaScript 可以在提交表单时对文件扩展名做检查，以防止用户上传无效格式的文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-file-upload&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> filename = f.<span class="property">value</span>;</span><br><span class="line"><span class="keyword">if</span> (!filename || !(filename.<span class="title function_">endsWith</span>(<span class="string">&quot;.jpg&quot;</span>) || filename.<span class="title function_">endsWith</span>(<span class="string">&quot;.png&quot;</span>) || filename.<span class="title function_">endsWith</span>(<span class="string">&quot;.gif&quot;</span>))) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Can only upload image file.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h4><p>由于 JavaScript 对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用 Flash 这样的第三方插件来实现。</p>
<p>随着 HTML5 的普及，新增的 File API 允许 JavaScript 读取文件内容，获得更多的文件信息。</p>
<p>HTML5 的 File API 提供了 <code>File</code> 和 <code>FileReader</code> 两个主要对象，可以获得文件信息并读取文件。</p>
<p>下面的例子演示了如何读取用户选取的图片文件，并在一个 <code>&lt;div&gt;</code> 中预览图像：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-image-file&quot;</span>),</span><br><span class="line">    info = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-file-info&quot;</span>),</span><br><span class="line">    preview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-image-preview&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 change 事件：</span></span><br><span class="line">fileInput.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除背景图片：</span></span><br><span class="line">    preview.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 检查文件是否选择：</span></span><br><span class="line">    <span class="keyword">if</span> (!fileInput.<span class="property">value</span>) &#123;</span><br><span class="line">        info.<span class="property">innerHTML</span> = <span class="string">&quot;没有选择文件&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 File 引用：</span></span><br><span class="line">    <span class="keyword">var</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取 File 信息：</span></span><br><span class="line">    info.<span class="property">innerHTML</span> = <span class="string">&quot;文件：&quot;</span> + file.<span class="property">name</span> + <span class="string">&quot;&lt;br&gt;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;大小：&quot;</span> + file.<span class="property">size</span> + <span class="string">&quot;&lt;br&gt;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;修改：&quot;</span> + file.<span class="property">lastModifiedDate</span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="property">type</span> !== <span class="string">&quot;image/jpeg&quot;</span> &amp;&amp; file.<span class="property">type</span> !== <span class="string">&quot;image/png&quot;</span> &amp;&amp; file.<span class="property">type</span> !== <span class="string">&quot;image/gif&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;不是有效的图片文件！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件：</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            data = e.<span class="property">target</span>.<span class="property">result</span>; <span class="comment">// &quot;data:image/jpeg;base64,/9j/4AAQSk…(base64编码)…&quot;            </span></span><br><span class="line">        preview.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">&quot;url(&quot;</span> + data + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以 DataURL 的形式读取文件：</span></span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码演示了如何通过 HTML5 的 File API 读取文件内容。以 DataURL 的形式读取到的文件是一个字符串，类似于 <code>data:image/jpeg;base64,/9j/4AAQSk…(base64编码)…</code>，常用于设置图像。如果需要服务器端处理，把字符串 <code>base64,</code> 后面的字符发送给服务器并用 Base64 解码就可以得到原始文件的二进制内容。</p>
<h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>上面的代码还演示了 JavaScript 的一个重要的特性，就是单线程执行模式。在 JavaScript 中，浏览器的 JavaScript 执行引擎在执行 JavaScript 代码时，总是以单线程模式执行，也就是说，任何时候 JavaScript 代码都不可能同时有多于 1 个线程在执行。</p>
<p>在 JavaScript 中，执行多任务实际上都是异步调用，比如上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.<span class="title function_">readAsDataURL</span>(file);</span><br></pre></td></tr></table></figure>
<p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以在 JavaScript 代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 当文件读取完成后，自动调用此函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当文件读取完成后，JavaScript 引擎将自动调用设置的回调函数。执行回调函数时，文件已经读取完毕，所以可以在回调函数内部安全地获得文件内容。</p>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX 全称 Asynchronous JavaScript and XML，意思是用 JavaScript 执行异步网络请求。</p>
<p>如果仔细观察一个 Form 的提交就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里显示操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个 404 页面。</p>
<p>这就是 Web 的运作原理：一次 HTTP 请求对应一个页面。</p>
<p>如果要让用户留在当前页面中，同时发出新的 HTTP 请求，就必须用 JavaScript 发送这个新请求，接收到数据后，再用 JavaScript 更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p>
<p>最早大规模使用 AJAX 的是 Gmail。Gmail 的页面在首次加载后，剩下的所有数据都依赖于 AJAX 来更新。</p>
<p>用 JavaScript 写一个完整的 AJAX 代码并不复杂，但是需要注意：AJAX 请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<p>在现代浏览器上写 AJAX 主要依靠 <code>XMLHttpRequest</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">success</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-response-text&quot;</span>);</span><br><span class="line">    textarea.<span class="property">value</span> = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-response-text&quot;</span>);</span><br><span class="line">    textarea.<span class="property">value</span> = <span class="string">&quot;Error code: &quot;</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">// 新建 XMLHttpRequest 对象</span></span><br><span class="line"></span><br><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果：</span></span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过 responseText 拿到响应的文本：</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">success</span>(request.<span class="property">responseText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因：</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fail</span>(request.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP 请求还在继续……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/categories&quot;</span>);</span><br><span class="line">request.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请求已发送，请等待响应……&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当创建了 <code>XMLHttpRequest</code> 对象后，要先设置 <code>onreadystatechange</code> 的回调函数。在回调函数中，通常只需通过 <code>readyState === 4</code> 判断请求是否完成。如果已完成，再根据 <code>status === 200</code> 判断是否是一个成功的响应。</p>
<p><code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法有 3 个参数：第一个参数指定是 <code>GET</code> 还是 <code>POST</code>；第二个参数指定 URL 地址；第三个参数指定是否使用异步，默认是 true，所以不用写。</p>
<p>注意，千万不要把第三个参数指定为 <code>false</code>，否则浏览器将停止响应，直到 AJAX 请求完成。如果这个请求耗时 10 秒，那么 10 秒内浏览器会处于“假死”状态。</p>
<p>最后调用 <code>send()</code> 方法才真正发送请求。<code>GET</code> 请求不需要参数，<code>POST</code> 请求需要把 body 部分以字符串或者 <code>FormData</code> 对象传进去。</p>
<h4 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h4><p>上面代码的 URL 使用的是相对路径。如果改为其它的绝对路径，肯定会报错。</p>
<p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript 在发送 AJAX 请求时，URL 的域名必须和当前页面完全一致。</p>
<p>完全一致的意思是，域名要相同（<code>www.example.com</code> 和 <code>example.com</code> 不同），协议要相同（<code>HTTP</code> 和 <code>HTTPS</code> 不同），端口号要相同（默认是 <code>:80</code> 端口，它和 <code>:8080</code> 就不同）。</p>
<p>想要用 JavaScript 请求外域（其他网站）的 URL，大概有以下几种方式：</p>
<p>一是通过在同源域名下架设一个代理服务器来转发，JavaScript 负责把请求发送到代理服务器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;/proxy?url=http://www.sina.com.cn&quot;</span></span><br></pre></td></tr></table></figure>
<p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p>
<p>二是使用 JSONP，它有个限制，只能用 GET 请求，并且要求返回 JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用 JavaScript 资源：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://example.com/abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSONP 通常以函数调用的形式返回。例如，返回 JavaScript 内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;data&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样一来，如果在页面中先准备好 <code>foo()</code> 函数，然后给页面动态加一个 <code>&lt;script&gt;</code> 节点，相当于动态读取外域的 JavaScript 资源，最后就等着接收回调了。</p>
<p>以 163 的股票查询 URL 为例，对于 URL：<a target="_blank" rel="noopener" href="https://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，将得到如下返回：">https://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，将得到如下返回：</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refreshPrice(&#123;<span class="string">&quot;0000001&quot;</span>:&#123;<span class="string">&quot;code&quot;</span>: <span class="string">&quot;0000001&quot;</span>, … &#125;);</span><br></pre></td></tr></table></figure>
<p>因此需要首先在页面中准备好回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">refreshPrice</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-jsonp&quot;</span>);</span><br><span class="line">    p.<span class="property">innerHTML</span> = <span class="string">&quot;当前价格：&quot;</span> +</span><br><span class="line">        data[<span class="string">&quot;0000001&quot;</span>].<span class="property">name</span> + <span class="string">&quot;：&quot;</span> +</span><br><span class="line">        data[<span class="string">&quot;0000001&quot;</span>].<span class="property">price</span> + <span class="string">&quot;；&quot;</span> +</span><br><span class="line">        data[<span class="string">&quot;1399001&quot;</span>].<span class="property">name</span> + <span class="string">&quot;：&quot;</span> +</span><br><span class="line">        data[<span class="string">&quot;1399001&quot;</span>].<span class="property">price</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后用 <code>getPrice()</code> 函数触发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPrice</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        js = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>),</span><br><span class="line">        head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    js.<span class="property">src</span> = <span class="string">&quot;https://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&quot;</span>;</span><br><span class="line">    head.<span class="title function_">appendChild</span>(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就完成了跨域加载数据。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>如果浏览器支持 HTML5，那就可以直接使用新的跨域策略——CORS。</p>
<p>CORS 全称 Cross-Origin Resource Sharing，是 HTML5 规范定义的如何跨域访问资源。</p>
<p>了解 CORS 前，先搞明白概念：</p>
<p>Origin 表示本域，也就是浏览器当前页面的域。当 JavaScript 向外域（如 <a target="_blank" rel="noopener" href="http://sina.com/">sina.com</a>）发起请求后，浏览器收到响应后，首先检查 <code>Access-Control-Allow-Origin</code> 是否包含本域。如果是，则此次跨域请求成功；如果不是，则请求失败，JavaScript 将无法获取到响应的任何数据。用图来表示就是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-b2204f5374c5c5a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp" alt="img"></p>
<p>CORS 原理</p>
<p>假设本域是 <code>my.com</code>，外域是 <code>sina.com</code>，只要响应头 <code>Access-Control-Allow-Origin</code> 为 <code>http://my.com</code>，或者是 <code>*</code>，本次请求就可以成功。</p>
<p>可见，跨域能否成功，取决于对方服务器是否愿意设置一个正确的 <code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p>
<p>上面这种跨域请求，称之为“简单请求”。简单请求包括 GET、HEAD 和 POST（POST 的 Content-Type 类型仅限 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 和 <code>text/plain</code>），并且不能出现任何自定义头（例如 <code>X-Custom: 12345</code>），通常能满足多数需求。</p>
<p>无论是否需要用 JavaScript 通过 CORS 跨域请求资源，都要了解 CORS 的原理。最新的浏览器全面支持 HTML5。在引用外域资源时，除了 JavaScript 和 CSS 外，都要验证 CORS。例如，当引用了某个第三方 CDN 上的字体文件时：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;FontAwesome&quot;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;http://cdn.com/fonts/fontawesome.ttf&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;truetype&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该 CDN 服务商未正确设置 <code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>
<p>对于 PUT、DELETE 以及其他类型如 <code>application/json</code> 的 POST 请求，在发送 AJAX 请求之前，浏览器会先发送一个 <code>OPTIONS</code> 请求（称为预检请求）到这个 URL 上，询问目标服务器是否接受：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/path/to/resource</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.com</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://my.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>POST</span><br></pre></td></tr></table></figure>
<p>服务器必须响应并明确指出允许的 Method：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://my.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>POST, GET, PUT, OPTIONS</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>86400</span><br></pre></td></tr></table></figure>
<p>浏览器确认服务器响应的 <code>Access-Control-Allow-Methods</code> 头确实包含将要发送的 AJAX 请求的 Method，才会继续发送 AJAX，否则抛出一个错误。</p>
<p>由于以 <code>POST</code>、<code>PUT</code> 方式传送 JSON 格式的数据在 REST 中很常见，所以要跨域正确处理 <code>POST</code> 和 <code>PUT</code> 请求，服务器端必须正确响应 <code>OPTIONS</code> 请求。</p>
<p>需要深入了解 CORS 的可查阅 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/cors/">W3C 文档</a>。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>在 JavaScript 的世界中，所有代码都是单线程执行的。</p>
<p>由于这个“缺陷”，导致 JavaScript 的所有网络操作、浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before setTimeout()&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(callback, <span class="number">1000</span>); <span class="comment">// 1 秒后调用 callback() 函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after setTimeout()&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">before <span class="title">setTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">after <span class="title">setTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 等待 1 秒后</span></span></span><br><span class="line"><span class="function">Done</span></span><br></pre></td></tr></table></figure>
<p>可见，异步操作会在将来的某个时间点触发一个函数调用。</p>
<p>AJAX 就是典型的异步操作。以上一节的代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">success</span>(request.<span class="property">responseText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fail</span>(request.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>把回调函数 <code>success(request.responseText)</code> 和 <code>fail(request.status)</code> 写到一个 AJAX 操作里很正常，但是不好看，而且不利于代码复用。</p>
<p>自然会想要追求更简单的写法，比如这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="title function_">ajaxGet</span>(<span class="string">&quot;http://…&quot;</span>);</span><br><span class="line">ajax.<span class="title function_">ifSuccess</span>(success)</span><br><span class="line">    .<span class="title function_">ifFail</span>(fail);</span><br></pre></td></tr></table></figure>
<p>这种链式写法的好处在于，先统一执行 AJAX 逻辑，不关心如何处理结果，然后根据结果是成功还是失败，在将来的某个时候调用 <code>success()</code> 函数或 <code>fail()</code> 函数。</p>
<p>这种“承诺将来会执行”的对象在 JavaScript 中称为 Promise 对象。</p>
<p>先看一个最简单的 Promise 例子：生成一个 0～2 之间的随机数。如果小于 1，则等待一段时间后返回成功，否则返回失败：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&quot;set timeout to: &quot;</span> + timeOut + <span class="string">&quot; seconds.&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&quot;call resolve()…&quot;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;200 OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&quot;call reject()…&quot;</span>);</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&quot;timeout in &quot;</span> + timeOut + <span class="string">&quot; seconds.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>test()</code> 函数有两个参数，这两个参数都是函数。如果执行成功，将调用 <code>resolve(&quot;200 OK&quot;)</code>；如果执行失败，将调用 <code>reject(&quot;timeout in &quot; + timeOut + &quot; seconds.&quot;)</code>。可以看出，<code>test()</code> 函数只关心自身的逻辑，并不关心具体的 <code>resolve()</code> 和 <code>reject()</code> 将如何处理结果。</p>
<p>有了执行函数，就可以用一个 Promise 对象来执行它，并在将来某个时刻获得成功或失败的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(test);</span><br><span class="line"><span class="keyword">var</span> p2 = p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功：&quot;</span> + result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = p2.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败：&quot;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>变量 <code>p1</code> 是一个 Promise 对象，它负责执行 <code>test()</code> 函数。由于 <code>test()</code> 函数在内部是异步执行的，当 <code>test()</code> 函数执行成功时，告诉 Promise 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果成功，执行这个函数：</span></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功：&quot;</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当 <code>test()</code> 函数执行失败时，告诉 Promise 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败：&quot;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 对象可以串联起来，所以上述代码可以简化为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(test).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功：&quot;</span> + result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败：&quot;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实际测试一下，看看 Promise 是如何异步执行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 log：</span></span><br><span class="line"><span class="keyword">var</span> logging = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-promise-log&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (logging.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    logging.<span class="title function_">removeChild</span>(logging.<span class="property">children</span>[logging.<span class="property">children</span>.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 log 到页面：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">    p.<span class="property">innerHTML</span> = s;</span><br><span class="line">    logging.<span class="title function_">appendChild</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&quot;start new Promise…&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&quot;set timeout to: &quot;</span> + timeOut + <span class="string">&quot; seconds.&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&quot;call resolve()…&quot;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;200 OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&quot;call reject()…&quot;</span>);</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&quot;timeout in &quot;</span> + timeOut + <span class="string">&quot; seconds.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">r</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&quot;Done: &quot;</span> + r);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&quot;Failed: &quot;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start <span class="keyword">new</span> <span class="title class_">Promise</span>…</span><br><span class="line">set timeout <span class="attr">to</span>: <span class="number">0.6643159176821918</span> seconds.</span><br><span class="line">call <span class="title function_">resolve</span>()…</span><br><span class="line"><span class="title class_">Done</span>: <span class="number">200</span> <span class="variable constant_">OK</span></span><br></pre></td></tr></table></figure>
<p>可见 Promise 最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-0a5d926c0bc240aa.png?imageMogr2/auto-orient/strip|imageView2/2/w/512/format/webp" alt="img"></p>
<p>Promise 的执行流程</p>
<p>Promise 还可以做更多的事情。比如，有若干个异步任务，需要先做任务 1，如果成功后再做任务 2，任何任务失败则不再继续并执行错误处理函数。</p>
<p>要串行执行这样的异步任务，不用 Promise 需要写一层一层的嵌套代码。有了 Promise，只需要简单地写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job1.<span class="title function_">then</span>(job2).<span class="title function_">then</span>(job3).<span class="title function_">catch</span>(handleError);</span><br></pre></td></tr></table></figure>
<p>其中，<code>job1</code>、<code>job2</code> 和 <code>job3</code> 都是 Promise 对象。</p>
<p>下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logging = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-promise2-log&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (logging.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    logging.<span class="title function_">removeChild</span>(logging.<span class="property">children</span>[logging.<span class="property">children</span>.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">    p.<span class="property">innerHTML</span> = s;</span><br><span class="line">    logging.<span class="title function_">appendChild</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.5 秒后返回 input × input 的计算结果:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&quot;calculating &quot;</span> + input + <span class="string">&quot; x &quot;</span> + input + <span class="string">&quot;…&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, input * input);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.5 秒后返回 input + input 的计算结果:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&quot;calculating &quot;</span> + input + <span class="string">&quot; + &quot;</span> + input + <span class="string">&quot;…&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, input + input);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&quot;start new Promise…&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(multiply)</span><br><span class="line">    .<span class="title function_">then</span>(add)</span><br><span class="line">    .<span class="title function_">then</span>(multiply)</span><br><span class="line">    .<span class="title function_">then</span>(add)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&quot;Got value: &quot;</span> + result);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start <span class="keyword">new</span> Promise…</span><br><span class="line">calculating <span class="number">123</span> x <span class="number">123</span>…</span><br><span class="line">calculating <span class="number">15129</span> + <span class="number">15129</span>…</span><br><span class="line">calculating <span class="number">30258</span> x <span class="number">30258</span>…</span><br><span class="line">calculating <span class="number">915546564</span> + <span class="number">915546564</span>…</span><br><span class="line">Got <span class="keyword">value</span>: <span class="number">1831093128</span></span><br></pre></td></tr></table></figure>
<p><code>setTimeout()</code> 可以看成一个模拟网络等异步执行的函数。现在，把上一节的 AJAX 异步执行函数转换为 Promise 对象，看看用 Promise 如何简化异步处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax() 函数将返回 Promise 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">method, url, data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(request.<span class="property">responseText</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(request.<span class="property">status</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        request.<span class="title function_">open</span>(method, url);</span><br><span class="line">        request.<span class="title function_">send</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-promise-ajax-result&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">ajax</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/categories&quot;</span>);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">text</span>) &#123; <span class="comment">// 如果 AJAX 成功，获得响应内容</span></span><br><span class="line">    log.<span class="property">innerText</span> = text;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">status</span>) &#123; <span class="comment">// 如果 AJAX 失败，获得响应代码</span></span><br><span class="line">    log.<span class="property">innerText</span> = <span class="string">&quot;ERROR: &quot;</span> + status;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;categories&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;0013738748415562fee26e070fa4664ad926c8e30146c67000&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;编程&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span><span class="string">&quot;tech&quot;</span><span class="punctuation">,</span><span class="attr">&quot;display_order&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span><span class="number">1373874841556</span><span class="punctuation">,</span><span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span><span class="number">1429763779958</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;0013738748248885ddf38d8cd1b4803aa74bcda32f853fd000&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;读书&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span><span class="string">&quot;other&quot;</span><span class="punctuation">,</span><span class="attr">&quot;display_order&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span><span class="number">1373874824888</span><span class="punctuation">,</span><span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span><span class="number">1429763779974</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>除了串行执行若干异步任务外，Promise 还可以并行执行异步任务。</p>
<p>试想一个页面聊天系统，需要从两个不同的 URL 分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用 <code>Promise.all()</code> 实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&quot;P1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&quot;P2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同时执行 p1 和 p2，并在它们都完成后执行 then()：</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// 获得一个数组 [&quot;P1&quot;, &quot;P2&quot;]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个 URL 读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用 <code>Promise.race()</code> 实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&quot;P1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&quot;P2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;P1&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于 <code>p1</code> 执行较快，Promise 的 <code>then()</code> 将获得结果 <code>&quot;P1&quot;</code>。<code>p2</code> 仍在继续执行，但执行结果将被丢弃。</p>
<p>如果组合使用 Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas 是 HTML5 新增的组件，它就像一块幕布，可以用 JavaScript 在上面绘制各种图表、动画等。</p>
<p>一个 Canvas 定义了一个指定尺寸的矩形框，在这个范围内可以随意绘制：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;test-canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>getContext(&quot;2d&quot;)</code> 方法获得一个 <code>CanvasRenderingContext2D</code> 对象，所有的绘图操作都需要通过这个对象完成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>HTML5 还有一个 WebGL 规范，允许在 Canvas 中绘制 3D 图形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h4><p>可以在 Canvas 上绘制各种形状。在绘制前，需要先了解一下 Canvas 的坐标系统：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https:////upload-images.jianshu.io/upload_images/9055492-1a641093fce8b748.png?imageMogr2/auto-orient/strip|imageView2/2/w/254/format/webp" alt="img"></p>
<p>Canvas 的坐标系统</p>
<p>Canvas 的坐标以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴，以像素为单位，所以每个点都是非负整数。</p>
<p><code>CanvasRenderingContext2D</code> 对象有若干方法来绘制图形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-shape-canvas&quot;</span>),</span><br><span class="line">    ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>); <span class="comment">// 擦除 (0, 0) 位置大小为 200×200 的矩形，擦除的意思是把该区域变为透明</span></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&quot;#dddddd&quot;</span>; <span class="comment">// 设置颜色</span></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">130</span>, <span class="number">130</span>); <span class="comment">// 把 (10, 10) 位置大小为 130×130 的矩形涂色</span></span><br><span class="line"><span class="comment">// 利用 Path 绘制复杂路径：</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="keyword">new</span> <span class="title class_">Path2D</span>();</span><br><span class="line">path.<span class="title function_">arc</span>(<span class="number">75</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">path.<span class="title function_">moveTo</span>(<span class="number">110</span>, <span class="number">75</span>);</span><br><span class="line">path.<span class="title function_">arc</span>(<span class="number">75</span>, <span class="number">75</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);</span><br><span class="line">path.<span class="title function_">moveTo</span>(<span class="number">65</span>, <span class="number">65</span>);</span><br><span class="line">path.<span class="title function_">arc</span>(<span class="number">60</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">path.<span class="title function_">moveTo</span>(<span class="number">95</span>, <span class="number">65</span>);</span><br><span class="line">path.<span class="title function_">arc</span>(<span class="number">90</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&quot;#0000ff&quot;</span>;</span><br><span class="line">ctx.<span class="title function_">stroke</span>(path);</span><br></pre></td></tr></table></figure>
<h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与 CSS 完全一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test-text-canvas&quot;</span>),</span><br><span class="line">    ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">ctx.<span class="property">shadowOffsetX</span> = <span class="number">2</span>;</span><br><span class="line">ctx.<span class="property">shadowOffsetY</span> = <span class="number">2</span>;</span><br><span class="line">ctx.<span class="property">shadowBlur</span> = <span class="number">2</span>;</span><br><span class="line">ctx.<span class="property">shadowColor</span> = <span class="string">&quot;#666666&quot;</span>;</span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&quot;24px Arial&quot;</span>;</span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&quot;#333333&quot;</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&quot;带阴影的文字&quot;</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>
<p>Canvas 除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</p>
<ul>
<li>通过创建一个不可见的 Canvas 来绘图，然后将最终绘制结果复制到页面的可见 Canvas 中；</li>
<li>尽量使用整数坐标而不是浮点数；</li>
<li>可以创建多个重叠的 Canvas 绘制不同的层，而不是在一个 Canvas 中绘制非常复杂的图；</li>
<li>背景图片如果不变可以直接用 <code>&lt;img&gt;</code> 标签并放到最底层。</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在执行 JavaScript 代码的时候，有些情况下会发生错误。</p>
<p>执行过程中，程序可能遇到无法预测的异常情况而报错。例如，网络连接中断，读取不存在的文件，没有操作权限等。对于这种错误，需要处理它，并可能需要给用户反馈。</p>
<p>同 Java、C# 等的异常处理机制类似，JavaScript 采用的也是 <code>try…catch…finally</code> 语句。基本逻辑是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出现错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 捕获错误后的处理部分</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否出现错误，最终都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>catch</code> 和 <code>finally</code> 都是可选的。这就意味着存在三种形式的 <code>try</code> 声明：</p>
<ul>
<li><code>try…catch</code></li>
<li><code>try…finally</code></li>
<li><code>try…catch…finally</code></li>
</ul>
<p>需要注意的是，根据规范，该语句块中只有一个 <code>catch</code> 子句，对于错误类型的判断则转交给 <code>catch</code> 子句体内部，而不是像 Java、C# 等那样的使用多个 <code>catch</code> 子句组成条件 <code>catch</code> 子句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">myroutine</span>(); <span class="comment">// 可能抛出多种错误</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">TypeError</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 TypeError 错误的语句</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">RangeError</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 RangeError 错误的语句</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">EvalError</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 EvalError 错误的语句</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理任何未指定的错误的语句</span></span><br><span class="line">        <span class="title function_">logMyErrors</span>(e); <span class="comment">// 将错误对象传递给错误处理程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序也可以主动抛出一个错误，让执行流程直接跳转到 <code>catch</code> 块。抛出错误使用 <code>throw</code> 语句。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r, n, s;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    s = <span class="title function_">prompt</span>(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">    n = <span class="built_in">parseInt</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r = n * n; <span class="comment">// 计算平方</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n + <span class="string">&quot; 的平方等于 &quot;</span> + r);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了：&quot;</span> + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，由于错误是层层抛出的，所以不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获、集中处理。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Xiao Tao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/cc1b9611.html">http://example.com/posts/cc1b9611.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">StudyBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://api.maho.cc/random-img/pc.php?9" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f3b98ae9.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.maho.cc/random-img/pc.php?2" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端</div></div></a></div><div class="next-post pull-right"><a href="/posts/d044eab7.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.maho.cc/random-img/pc.php?12" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TypeScript</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cravatar.cn/avatar/e2e440da3c8f5379912c8a9c4df4e420?s=96&amp;d=https%3A%2F%2Fcn.gravatar.com%2Favatar%2Fb745710ae6b0ce9dfb13f5b7c0956be1&amp;r=g" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xiao Tao</div><div class="author-info__description">一以贯之的努力，不得懈怠的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xiaotao2177393158" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据类型和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%EF%BC%88number%EF%BC%89"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">数字（number）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%EF%BC%88null%EF%BC%89%E5%92%8C%E6%9C%AA%E5%AE%9A%E4%B9%89%EF%BC%88undefined%EF%BC%89"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">空（null）和未定义（undefined）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88array%EF%BC%89"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">数组（array）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%EF%BC%88object%EF%BC%89"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">对象（object）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">严格模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">多行字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">操作字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#indexOf"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">indexOf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#substring"><span class="toc-number">1.1.3.3.2.</span> <span class="toc-text">substring</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">数组的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#slice"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#push-%E5%92%8C-pop"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">push 和 pop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unshift-%E5%92%8C-shift"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">unshift 和 shift</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sort"><span class="toc-number">1.1.4.1.4.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse"><span class="toc-number">1.1.4.1.5.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#splice"><span class="toc-number">1.1.4.1.6.</span> <span class="toc-text">splice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#concat"><span class="toc-number">1.1.4.1.7.</span> <span class="toc-text">concat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#join"><span class="toc-number">1.1.4.1.8.</span> <span class="toc-text">join</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.5.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">1.1.6.</span> <span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.7.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E2%80%A6-in"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">for … in</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E5%92%8C-Set"><span class="toc-number">1.1.8.</span> <span class="toc-text">Map 和 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">Set</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%EF%BC%88iterable%EF%BC%89"><span class="toc-number">1.1.9.</span> <span class="toc-text">迭代（iterable）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数定义和调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arguments"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rest-%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">rest 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#return-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">return 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.2.2.</span> <span class="toc-text">变量作用域与解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">局部作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#apply"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">装饰器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%EF%BC%88filter%EF%BC%89"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">过滤（filter）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%EF%BC%88sort%EF%BC%89"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">排序（sort）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">闭包（closure）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">函数作为返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88generator%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">生成器（generator）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">标准对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">包装对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Date"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">时区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88RegExp%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">正则表达式（RegExp）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">切分字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">贪婪匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">全局搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.1.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E5%B0%91-new-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">缺少 new 的构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.2.</span> <span class="toc-text">原型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.3.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">class 继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">浏览器对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#window"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">window</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#navigator"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">navigator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#screen"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">screen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#location"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">location</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">document</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-DOM"><span class="toc-number">1.5.2.</span> <span class="toc-text">操作 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0-DOM"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">更新 DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-DOM"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">插入 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#insertBefore"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">insertBefore</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-DOM"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">删除 DOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%A1%A8%E5%8D%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">操作表单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">获取值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%80%BC"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">设置值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">提交表单</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.4.</span> <span class="toc-text">操作文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#File-API"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">File API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">回调</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AJAX"><span class="toc-number">1.5.5.</span> <span class="toc-text">AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%99%90%E5%88%B6"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">安全限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">CORS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">1.5.6.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas"><span class="toc-number">1.5.7.</span> <span class="toc-text">Canvas</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%BD%A2%E7%8A%B6"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">绘制形状</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">绘制文本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">错误处理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ba23b44c.html" title="阿里云短信接码"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.maho.cc/random-img/pc.php?15" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里云短信接码"/></a><div class="content"><a class="title" href="/posts/ba23b44c.html" title="阿里云短信接码">阿里云短信接码</a><time datetime="2023-02-23T03:24:55.625Z" title="发表于 2023-02-23 11:24:55">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d044eab7.html" title="TypeScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.maho.cc/random-img/pc.php?12" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/posts/d044eab7.html" title="TypeScript">TypeScript</a><time datetime="2023-02-23T03:24:55.625Z" title="发表于 2023-02-23 11:24:55">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cc1b9611.html" title="JavaScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.maho.cc/random-img/pc.php?9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript"/></a><div class="content"><a class="title" href="/posts/cc1b9611.html" title="JavaScript">JavaScript</a><time datetime="2023-02-23T03:24:55.624Z" title="发表于 2023-02-23 11:24:55">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f3b98ae9.html" title="前端"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.maho.cc/random-img/pc.php?2" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端"/></a><div class="content"><a class="title" href="/posts/f3b98ae9.html" title="前端">前端</a><time datetime="2023-02-23T03:24:55.623Z" title="发表于 2023-02-23 11:24:55">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/60d97b56.html" title="8大排序算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.maho.cc/random-img/pc.php?16" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="8大排序算法"/></a><div class="content"><a class="title" href="/posts/60d97b56.html" title="8大排序算法">8大排序算法</a><time datetime="2023-02-23T03:24:55.623Z" title="发表于 2023-02-23 11:24:55">2023-02-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xiao Tao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Copyright © by xiaotao All Rights Reserved. <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="icp图片"><span>备案号：滇ICP备2021007136号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/pluginsSrc/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('/pluginsSrc/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Valine' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="7610399911" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/pluginsSrc/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/aplayer/dist/APlayer.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="/pluginsSrc/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.0.5/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '1b7ad4c552264b689ab62ff5a16d3ebb';
  var gaud_map_key = '782c289c7b4409794e9ae6ee69601478';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.0.5/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>